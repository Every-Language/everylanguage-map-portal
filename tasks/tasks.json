{
  "tasks": [
    {
      "id": 1,
      "title": "Setup Project Repository and Base Configuration",
      "description": "Initialize the React TypeScript project with Tailwind CSS, configure ESLint, and set up the basic project structure.",
      "status": "done",
      "dependencies": [],
      "priority": "high",
      "details": "Create a new React project using create-react-app with TypeScript template. Configure Tailwind CSS following their documentation. Set up ESLint with TypeScript rules. Create the basic folder structure: components/, hooks/, pages/, utils/, types/, services/, assets/. Initialize Git repository and create the initial commit.",
      "testStrategy": "Verify that the project builds without errors. Ensure Tailwind CSS is working by testing a simple styled component.",
      "subtasks": [
        {
          "id": 1,
          "title": "Initialize React TypeScript Project with Vite",
          "description": "Set up a new React TypeScript project using Vite for faster development and optimized builds, and install core dependencies.",
          "dependencies": [],
          "details": "1. Create a new project using Vite with React TypeScript template: `npm create vite@latest my-app --template react-ts`\n2. Navigate to project directory: `cd my-app`\n3. Install core dependencies: `npm install react@latest react-dom@latest react-router-dom@6`\n4. Install TypeScript type definitions: `npm install -D @types/react @types/react-dom`\n5. Initialize Git repository: `git init`\n6. Create .gitignore file with node_modules, dist, and other build artifacts\n7. Make initial commit: `git add . && git commit -m \"Initial project setup\"`\n8. Test the setup by running `npm run dev` to ensure the development server starts correctly",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 2,
          "title": "Configure Tailwind CSS and Base Styling",
          "description": "Install and configure Tailwind CSS with PostCSS for utility-first styling approach, and set up the base styling for the project.",
          "dependencies": [
            1
          ],
          "details": "1. Install Tailwind CSS and its dependencies: `npm install -D tailwindcss postcss autoprefixer`\n2. Initialize Tailwind configuration: `npx tailwindcss init -p`\n3. Configure content paths in tailwind.config.js to scan source files:\n```js\nexport default {\n  content: [\"./index.html\", \"./src/**/*.{js,ts,jsx,tsx}\"],\n  theme: {\n    extend: {},\n  },\n  plugins: [],\n}\n```\n4. Add Tailwind directives to src/index.css:\n```css\n@tailwind base;\n@tailwind components;\n@tailwind utilities;\n```\n5. Ensure the CSS is imported in src/main.tsx\n6. Create a simple component to test Tailwind classes\n7. Test the setup by adding Tailwind classes to existing components and verifying they apply correctly",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 3,
          "title": "Set Up ESLint and Prettier for Code Quality",
          "description": "Configure ESLint with TypeScript rules and Prettier for consistent code formatting and quality enforcement.",
          "dependencies": [
            1
          ],
          "details": "1. Install ESLint, Prettier, and related plugins: `npm install -D eslint prettier eslint-config-prettier eslint-plugin-react eslint-plugin-react-hooks @typescript-eslint/eslint-plugin @typescript-eslint/parser`\n2. Create .eslintrc.cjs file with recommended settings:\n```js\nmodule.exports = {\n  parser: '@typescript-eslint/parser',\n  extends: [\n    'eslint:recommended',\n    'plugin:react/recommended',\n    'plugin:@typescript-eslint/recommended',\n    'prettier'\n  ],\n  plugins: ['react', '@typescript-eslint', 'react-hooks'],\n  rules: {\n    'react/react-in-jsx-scope': 'off',\n    'react/prop-types': 'off'\n  },\n  settings: {\n    react: {\n      version: 'detect'\n    }\n  }\n};\n```\n3. Create .prettierrc file for formatting consistency:\n```json\n{\n  \"singleQuote\": true,\n  \"semi\": true,\n  \"trailingComma\": \"all\",\n  \"tabWidth\": 2\n}\n```\n4. Add lint and format scripts to package.json:\n```json\n\"scripts\": {\n  \"lint\": \"eslint . --ext .ts,.tsx\",\n  \"format\": \"prettier --write .\"\n}\n```\n5. Test the setup by running `npm run lint` and `npm run format` to ensure they work correctly",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 4,
          "title": "Create Project Folder Structure",
          "description": "Establish a scalable and maintainable folder structure following best practices for React TypeScript applications.",
          "dependencies": [
            1
          ],
          "details": "1. Create the following directory structure in the src folder:\n   - components/ (for reusable UI components)\n   - pages/ (for route-level components)\n   - hooks/ (for custom React hooks)\n   - utils/ (for utility functions)\n   - types/ (for TypeScript type definitions)\n   - services/ (for API calls and external services)\n   - assets/ (for images, fonts, etc.)\n2. Create index.ts files in each directory to facilitate clean imports\n3. Add placeholder files or basic implementations in each folder:\n   - components/Button.tsx (a simple button component)\n   - pages/Home.tsx (a basic home page)\n   - hooks/useWindowSize.ts (a window size hook)\n   - utils/formatters.ts (date/string formatters)\n4. Update App.tsx to use the new folder structure\n5. Test the imports and component rendering to ensure the structure works correctly",
          "status": "done",
          "parentTaskId": 1
        },
        {
          "id": 5,
          "title": "Configure Build and Development Environment",
          "description": "Set up scripts, environment variables, and development tools to streamline the development workflow.",
          "dependencies": [
            1,
            2,
            3
          ],
          "details": "1. Create environment variable files:\n   - .env (for shared variables)\n   - .env.development (for development-specific variables)\n   - .env.production (for production-specific variables)\n2. Add environment variable prefix VITE_ to ensure they're exposed to the client\n3. Update package.json scripts for development, building, and testing:\n```json\n\"scripts\": {\n  \"dev\": \"vite\",\n  \"build\": \"tsc && vite build\",\n  \"preview\": \"vite preview\",\n  \"lint\": \"eslint . --ext .ts,.tsx\",\n  \"format\": \"prettier --write .\",\n  \"test\": \"vitest run\"\n}\n```\n4. Install development tools for testing (optional): `npm install -D vitest jsdom @testing-library/react @testing-library/jest-dom`\n5. Configure vite.config.ts with plugins and build options:\n```ts\nimport { defineConfig } from 'vite'\nimport react from '@vitejs/plugin-react'\n\nexport default defineConfig({\n  plugins: [react()],\n  resolve: {\n    alias: {\n      '@': '/src'\n    }\n  }\n})\n```\n6. Create a tsconfig.paths.json file for path aliases (optional)\n7. Test the build process by running `npm run build` and `npm run preview` to ensure everything works correctly",
          "status": "done",
          "parentTaskId": 1
        }
      ]
    },
    {
      "id": 2,
      "title": "Integrate Supabase Authentication",
      "description": "Set up Supabase client and implement authentication flows including login, registration, and session management.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Install Supabase JS client. Create authentication service with login, logout, register, and password reset functions. Implement persistent session storage. Create login and registration forms with validation. Set up protected routes using React Router. Implement role-based access control using Supabase RLS policies.",
      "testStrategy": "Test user registration, login, logout, and session persistence. Verify that protected routes redirect unauthenticated users to login page.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up Supabase client and environment configuration",
          "description": "Initialize the Supabase client with proper environment variables and create a centralized configuration file for authentication services.",
          "dependencies": [],
          "details": "1. Install required dependencies: `npm install @supabase/supabase-js`\n2. Create environment variables in `.env` file for Supabase URL and anon key (use appropriate prefix like REACT_APP_ or NEXT_PUBLIC_ depending on your framework)\n3. Create a `supabaseClient.js` file that initializes the Supabase client using environment variables\n4. Add proper error handling for initialization failures\n5. Set up CORS configuration in Supabase dashboard to whitelist your frontend domain\n6. Test the connection by making a simple query\n7. Document the setup process for other developers\n\nTesting approach: Verify client initialization works without errors and can make a basic public query to Supabase.",
          "status": "done",
          "parentTaskId": 2
        },
        {
          "id": 2,
          "title": "Implement authentication service with core functions",
          "description": "Create a dedicated authentication service that handles login, registration, logout, and password reset functionality using the Supabase client.",
          "dependencies": [
            1
          ],
          "details": "1. Create an `authService.js` file that imports the Supabase client\n2. Implement the following functions with proper error handling:\n   - `signUp(email, password)` - User registration\n   - `signIn(email, password)` - User login with credentials\n   - `signInWithProvider(provider)` - OAuth login (if needed)\n   - `signOut()` - User logout\n   - `resetPassword(email)` - Password reset request\n   - `updatePassword(password)` - Update password after reset\n3. Add appropriate validation for inputs\n4. Include comprehensive error handling with user-friendly error messages\n5. Add logging for authentication events (for debugging)\n\nTesting approach: Create unit tests for each authentication function using a testing framework like Jest, mocking the Supabase responses. Test both success and error scenarios.",
          "status": "done",
          "parentTaskId": 2
        },
        {
          "id": 3,
          "title": "Create authentication context and session management",
          "description": "Implement a global authentication context using React Context API to manage user session state throughout the application.",
          "dependencies": [
            2
          ],
          "details": "1. Create an `AuthContext.js` file with React Context API\n2. Implement an AuthProvider component that:\n   - Maintains current user state\n   - Listens to auth state changes using `supabase.auth.onAuthStateChange`\n   - Provides methods to access the current user and authentication status\n   - Handles session persistence across page refreshes\n3. Create a custom hook `useAuth()` to easily access auth context\n4. Implement session retrieval on initial load using `supabase.auth.getSession()`\n5. Add proper cleanup for auth listeners when components unmount\n6. Handle token refresh logic to maintain long-lived sessions\n\nTesting approach: Test the AuthProvider with React Testing Library to ensure it correctly updates state on auth events and provides the expected context values.",
          "status": "done",
          "parentTaskId": 2
        },
        {
          "id": 4,
          "title": "Build login and registration forms with validation",
          "description": "Create user-friendly login and registration forms with proper validation, error handling, and user feedback.",
          "dependencies": [
            3
          ],
          "details": "1. Create reusable form components for:\n   - Login form with email/password fields\n   - Registration form with necessary fields\n   - Password reset request form\n   - Password update form\n2. Implement form validation using a library like Formik or React Hook Form\n3. Add validation rules for:\n   - Email format\n   - Password strength (min length, complexity)\n   - Required fields\n4. Connect forms to the authentication service methods\n5. Implement proper loading states during authentication\n6. Display user-friendly error messages from Supabase\n7. Add success feedback and redirects after successful operations\n\nTesting approach: Test form validation logic, submission handling, and UI state changes during authentication processes using component testing.\n\n<info added on 2025-07-13T23:52:54.633Z>\n## Implementation Details\n\n### Form Component Architecture\n- Implemented a composable form architecture with `FormProvider` from React Hook Form\n- Created custom form hooks (`useLoginForm`, `useRegisterForm`, etc.) to encapsulate validation logic\n- Used Zod schema validation integrated with React Hook Form for type-safe validation\n\n### Validation Implementation\n```typescript\n// Example password validation schema with Zod\nconst passwordSchema = z\n  .string()\n  .min(8, \"Password must be at least 8 characters\")\n  .regex(/[A-Z]/, \"Password must contain at least one uppercase letter\")\n  .regex(/[a-z]/, \"Password must contain at least one lowercase letter\")\n  .regex(/[0-9]/, \"Password must contain at least one number\");\n\n// Form schema example\nconst loginFormSchema = z.object({\n  email: z.string().email(\"Please enter a valid email address\"),\n  password: passwordSchema,\n  rememberMe: z.boolean().optional()\n});\n\ntype LoginFormValues = z.infer<typeof loginFormSchema>;\n```\n\n### Error Handling Strategy\n- Implemented custom error mapper to transform Supabase error codes into user-friendly messages\n- Created `<FormError>` component for consistent error display across forms\n- Added focus management to automatically focus first field with error\n\n### Accessibility Enhancements\n- Implemented ARIA live regions for form submission status announcements\n- Added proper focus management during form submission and error states\n- Ensured keyboard navigation works correctly through all form elements\n\n### OAuth Integration\n```typescript\n// OAuth button implementation with provider-specific handling\nconst OAuthButton = ({ provider, label }: OAuthButtonProps) => {\n  const { signInWithProvider, isLoading } = useAuth();\n  \n  const handleOAuthSignIn = async () => {\n    try {\n      await signInWithProvider(provider);\n    } catch (error) {\n      // Provider-specific error handling\n    }\n  };\n  \n  return (\n    <Button \n      onClick={handleOAuthSignIn}\n      isLoading={isLoading}\n      variant=\"outline\"\n      leftIcon={getProviderIcon(provider)}\n    >\n      {label}\n    </Button>\n  );\n};\n```\n\n### Testing Coverage\n- Added comprehensive Jest/React Testing Library tests for all form components\n- Implemented mock service worker (MSW) to simulate Supabase responses\n- Created test fixtures for different auth scenarios (success, various error types)\n- Added E2E tests with Cypress for critical auth flows\n</info added on 2025-07-13T23:52:54.633Z>",
          "status": "done",
          "parentTaskId": 2
        },
        {
          "id": 5,
          "title": "Implement protected routes and role-based access control",
          "description": "Set up route protection using React Router and implement role-based access control using Supabase Row Level Security (RLS) policies.",
          "dependencies": [
            3,
            4
          ],
          "details": "1. Create a `ProtectedRoute` component that:\n   - Checks for authenticated user using the auth context\n   - Redirects to login page if user is not authenticated\n   - Optionally checks for specific user roles\n2. Implement route configuration using React Router with protected routes\n3. Set up Supabase RLS policies for your database tables:\n   - Enable RLS on all sensitive tables\n   - Create policies that restrict access based on user authentication\n   - Add role-specific policies for different access levels\n4. Test RLS policies to ensure they correctly restrict unauthorized access\n5. Create helper functions to check user permissions in the UI\n6. Implement UI elements that conditionally render based on user roles\n\nTesting approach: Test protected routes by simulating authenticated and unauthenticated states. Verify RLS policies by attempting to access data with different user roles and ensuring proper restrictions are in place.\n\n<info added on 2025-07-14T02:20:24.743Z>\n## Implementation Details for Protected Routes and RBAC\n\n### ProtectedRoute Component Implementation\n```tsx\n// src/features/auth/components/ProtectedRoute.tsx\nimport { useAuth } from '../hooks/useAuth';\nimport { Navigate, useLocation } from 'react-router-dom';\nimport { hasRequiredRole } from '../utils/roleUtils';\n\ninterface ProtectedRouteProps {\n  children: React.ReactNode;\n  requiredRoles?: string[];\n}\n\nexport const ProtectedRoute = ({ children, requiredRoles }: ProtectedRouteProps) => {\n  const { user, isLoading } = useAuth();\n  const location = useLocation();\n\n  if (isLoading) {\n    return <div className=\"flex h-screen items-center justify-center\">\n      <div className=\"animate-pulse text-primary\">Loading authentication...</div>\n    </div>;\n  }\n\n  if (!user) {\n    // Save the attempted location for redirect after login\n    return <Navigate to=\"/login\" state={{ from: location.pathname }} replace />;\n  }\n\n  if (requiredRoles && !hasRequiredRole(user, requiredRoles)) {\n    return <Navigate to=\"/unauthorized\" replace />;\n  }\n\n  return <>{children}</>;\n};\n```\n\n### Role Utilities\n```tsx\n// src/features/auth/utils/roleUtils.ts\nimport { User } from '@supabase/supabase-js';\n\nexport const ROLES = {\n  ADMIN: 'admin',\n  PROJECT_MANAGER: 'project_manager',\n  TRANSLATOR: 'translator',\n  VIEWER: 'viewer'\n} as const;\n\nexport type UserRole = typeof ROLES[keyof typeof ROLES];\n\nexport const hasRole = (user: User, role: UserRole): boolean => {\n  // Access user.app_metadata.role from Supabase\n  return user?.app_metadata?.role === role;\n};\n\nexport const hasRequiredRole = (user: User, requiredRoles: string[]): boolean => {\n  const userRole = user?.app_metadata?.role;\n  return requiredRoles.includes(userRole);\n};\n```\n\n### Supabase RLS Policy Examples\n```sql\n-- Enable RLS on projects table\nALTER TABLE projects ENABLE ROW LEVEL SECURITY;\n\n-- Admin can do everything\nCREATE POLICY \"Admins have full access\" ON projects\n  USING (auth.jwt() -> 'app_metadata' ->> 'role' = 'admin');\n\n-- Project managers can view all projects but only edit their own\nCREATE POLICY \"Project managers can view all projects\" ON projects\n  FOR SELECT\n  USING (auth.jwt() -> 'app_metadata' ->> 'role' = 'project_manager');\n\nCREATE POLICY \"Project managers can edit their own projects\" ON projects\n  FOR UPDATE\n  USING (auth.jwt() -> 'app_metadata' ->> 'role' = 'project_manager' AND created_by = auth.uid());\n\n-- Translators can only view projects they're assigned to\nCREATE POLICY \"Translators view assigned projects\" ON projects\n  FOR SELECT\n  USING (\n    auth.jwt() -> 'app_metadata' ->> 'role' = 'translator' AND\n    id IN (SELECT project_id FROM project_assignments WHERE user_id = auth.uid())\n  );\n```\n\n### Route Configuration with Role-Based Protection\n```tsx\n// src/App.tsx\nimport { BrowserRouter, Routes, Route } from 'react-router-dom';\nimport { AuthProvider } from './features/auth/context/AuthContext';\nimport { ProtectedRoute } from './features/auth/components/ProtectedRoute';\nimport { ROLES } from './features/auth/utils/roleUtils';\n\nfunction App() {\n  return (\n    <BrowserRouter>\n      <AuthProvider>\n        <Routes>\n          <Route path=\"/login\" element={<LoginPage />} />\n          <Route path=\"/unauthorized\" element={<UnauthorizedPage />} />\n          \n          {/* Public routes */}\n          <Route path=\"/\" element={<LandingPage />} />\n          \n          {/* Protected routes - any authenticated user */}\n          <Route path=\"/dashboard\" element={\n            <ProtectedRoute>\n              <DashboardPage />\n            </ProtectedRoute>\n          } />\n          \n          {/* Admin-only routes */}\n          <Route path=\"/admin\" element={\n            <ProtectedRoute requiredRoles={[ROLES.ADMIN]}>\n              <AdminPage />\n            </ProtectedRoute>\n          } />\n          \n          {/* Project manager routes */}\n          <Route path=\"/projects/new\" element={\n            <ProtectedRoute requiredRoles={[ROLES.ADMIN, ROLES.PROJECT_MANAGER]}>\n              <NewProjectPage />\n            </ProtectedRoute>\n          } />\n        </Routes>\n      </AuthProvider>\n    </BrowserRouter>\n  );\n}\n```\n\n### UI Permission Helpers\n```tsx\n// src/features/auth/hooks/usePermissions.ts\nimport { useAuth } from './useAuth';\nimport { hasRole, UserRole } from '../utils/roleUtils';\n\nexport const usePermissions = () => {\n  const { user } = useAuth();\n  \n  return {\n    canCreateProject: user && (hasRole(user, 'admin') || hasRole(user, 'project_manager')),\n    canEditUsers: user && hasRole(user, 'admin'),\n    canAssignTranslators: user && (hasRole(user, 'admin') || hasRole(user, 'project_manager')),\n    canViewReports: user && (hasRole(user, 'admin') || hasRole(user, 'project_manager')),\n    // Add more permission checks as needed\n  };\n};\n\n// Usage in components:\n// const { canCreateProject } = usePermissions();\n// {canCreateProject && <Button>Create Project</Button>}\n```\n</info added on 2025-07-14T02:20:24.743Z>",
          "status": "done",
          "parentTaskId": 2
        }
      ]
    },
    {
      "id": 3,
      "title": "Setup State Management with Zustand",
      "description": "Implement Zustand stores for global state management across the application.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "high",
      "details": "Install Zustand. Create separate stores for authentication, project management, upload state, and UI state. Implement selectors for efficient state access. Set up middleware for persistence where needed. Create typed interfaces for all store states.",
      "testStrategy": "Write unit tests for store actions and selectors. Verify state persistence across page refreshes where applicable."
    },
    {
      "id": 4,
      "title": "Configure TanStack Query for API Integration",
      "description": "Set up TanStack Query for data fetching, caching, and state synchronization with the Supabase backend.",
      "status": "done",
      "dependencies": [
        1,
        2
      ],
      "priority": "high",
      "details": "Install TanStack Query. Create a query client provider. Set up base query hooks for Supabase tables. Implement custom hooks for common data operations. Configure global error handling and loading states. Set up optimistic updates for better UX.",
      "testStrategy": "Test query caching behavior. Verify that stale data is properly refreshed. Test error handling for network failures.",
      "subtasks": [
        {
          "id": 1,
          "title": "Install TanStack Query and Set Up Query Client Provider",
          "description": "Install TanStack Query packages and create a QueryClientProvider to wrap the application",
          "dependencies": [],
          "details": "1. Install required packages: `npm install @tanstack/react-query @tanstack/react-query-devtools`\n2. Create a `src/lib/query-client.ts` file to configure the QueryClient with default options\n3. Configure default options including staleTime, cacheTime, and retry policies\n4. Create a QueryProvider component in `src/providers/QueryProvider.tsx` that wraps children with QueryClientProvider\n5. Add React Query DevTools in development mode\n6. Update the main application component to use the QueryProvider\n7. Test by confirming the React Query DevTools panel appears in development mode\n\n<info added on 2025-07-14T09:04:04.766Z>\n## Implementation Details\n\n### Query Client Configuration\n```typescript\n// src/lib/query-client.ts\nimport { QueryClient } from '@tanstack/react-query';\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      cacheTime: 10 * 60 * 1000, // 10 minutes\n      retry: 3,\n      refetchOnWindowFocus: process.env.NODE_ENV === 'production',\n      useErrorBoundary: true,\n    },\n    mutations: {\n      retry: 1,\n      useErrorBoundary: true,\n    },\n  },\n});\n```\n\n### Query Keys Factory\n```typescript\n// src/lib/query-keys.ts\nexport const queryKeys = {\n  users: {\n    all: ['users'] as const,\n    detail: (id: string) => [...queryKeys.users.all, id] as const,\n    preferences: (id: string) => [...queryKeys.users.detail(id), 'preferences'] as const,\n  },\n  projects: {\n    all: ['projects'] as const,\n    detail: (id: string) => [...queryKeys.projects.all, id] as const,\n  },\n  // Add other entity keys as needed\n};\n```\n\n### QueryProvider Implementation\n```typescript\n// src/providers/QueryProvider.tsx\nimport { QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\nimport { queryClient } from '../lib/query-client';\n\ninterface QueryProviderProps {\n  children: React.ReactNode;\n}\n\nexport function QueryProvider({ children }: QueryProviderProps) {\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n      {process.env.NODE_ENV !== 'production' && <ReactQueryDevtools initialIsOpen={false} />}\n    </QueryClientProvider>\n  );\n}\n```\n\n### Main Application Integration\n```typescript\n// src/main.tsx\nimport React from 'react';\nimport ReactDOM from 'react-dom/client';\nimport App from './App';\nimport { QueryProvider } from './providers/QueryProvider';\n\nReactDOM.createRoot(document.getElementById('root')!).render(\n  <React.StrictMode>\n    <QueryProvider>\n      <App />\n    </QueryProvider>\n  </React.StrictMode>\n);\n```\n</info added on 2025-07-14T09:04:04.766Z>",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 2,
          "title": "Create Base Query Hooks for Supabase Tables",
          "description": "Implement generic base query hooks that interface with Supabase tables",
          "dependencies": [
            1
          ],
          "details": "1. Create a `src/hooks/query/base-hooks.ts` file\n2. Implement `useQuery` wrapper that handles Supabase specific response format\n3. Create `useFetchCollection` hook for fetching collections of data from Supabase tables\n4. Implement `useFetchById` hook for fetching single records by ID\n5. Add TypeScript generics to ensure type safety with different table schemas\n6. Implement proper error handling for Supabase errors\n7. Test hooks with simple queries to verify they correctly fetch and type data\n\n<info added on 2025-07-14T09:08:24.978Z>\n## Implementation Details\n\n### Base Hooks Implementation\n\n```typescript\n// src/hooks/query/base-hooks.ts\nimport { useQuery, UseQueryOptions } from '@tanstack/react-query';\nimport { supabase } from '@/lib/supabase-client';\nimport { PostgrestError } from '@supabase/supabase-js';\n\nexport interface SupabaseError {\n  message: string;\n  code: string;\n  details?: string;\n  hint?: string;\n}\n\nexport function transformError(error: PostgrestError): SupabaseError {\n  return {\n    message: error.message || 'An unknown error occurred',\n    code: error.code,\n    details: error.details,\n    hint: error.hint\n  };\n}\n\nexport function useFetchCollection<T>(\n  tableName: string,\n  options?: {\n    filters?: Record<string, any>;\n    orderBy?: { column: string; ascending?: boolean };\n    limit?: number;\n    offset?: number;\n    queryOptions?: UseQueryOptions<T[], SupabaseError>;\n  }\n) {\n  const { filters, orderBy, limit, offset, queryOptions } = options || {};\n  \n  return useQuery<T[], SupabaseError>({\n    queryKey: ['collection', tableName, filters, orderBy, limit, offset],\n    queryFn: async () => {\n      let query = supabase.from(tableName).select('*');\n      \n      // Apply filters\n      if (filters) {\n        Object.entries(filters).forEach(([key, value]) => {\n          if (value !== undefined) {\n            query = query.eq(key, value);\n          }\n        });\n      }\n      \n      // Apply ordering\n      if (orderBy) {\n        query = query.order(orderBy.column, { ascending: orderBy.ascending ?? true });\n      }\n      \n      // Apply pagination\n      if (limit) {\n        query = query.limit(limit);\n      }\n      \n      if (offset) {\n        query = query.range(offset, offset + (limit || 10) - 1);\n      }\n      \n      const { data, error } = await query;\n      \n      if (error) {\n        throw transformError(error);\n      }\n      \n      return data as T[];\n    },\n    ...queryOptions\n  });\n}\n\nexport function useFetchById<T>(\n  tableName: string,\n  id: string | number | undefined,\n  options?: {\n    queryOptions?: UseQueryOptions<T | null, SupabaseError>;\n  }\n) {\n  const { queryOptions } = options || {};\n  \n  return useQuery<T | null, SupabaseError>({\n    queryKey: ['item', tableName, id],\n    queryFn: async () => {\n      if (!id) return null;\n      \n      const { data, error } = await supabase\n        .from(tableName)\n        .select('*')\n        .eq('id', id)\n        .single();\n      \n      if (error) {\n        // Handle \"not found\" as a valid case returning null\n        if (error.code === 'PGRST116') {\n          return null;\n        }\n        throw transformError(error);\n      }\n      \n      return data as T;\n    },\n    enabled: !!id,\n    ...queryOptions\n  });\n}\n```\n\n### Example Usage Pattern\n\n```typescript\n// src/hooks/query/projects.ts\nimport { useFetchCollection, useFetchById } from './base-hooks';\nimport type { TableRow } from '@/types/database';\n\nexport function useProjects() {\n  return useFetchCollection<TableRow<'projects'>>('projects');\n}\n\nexport function useProject(id: string | undefined) {\n  return useFetchById<TableRow<'projects'>>('projects', id);\n}\n\nexport function useProjectsByUser(userId: string | undefined) {\n  return useFetchCollection<TableRow<'projects'>>('projects', {\n    filters: { user_id: userId },\n    queryOptions: {\n      enabled: !!userId\n    }\n  });\n}\n```\n\n### Type Safety Considerations\n\nFor proper type safety, create a `database.ts` type file:\n\n```typescript\n// src/types/database.ts\nimport { Database } from '@/lib/database.types'; // Generated from Supabase CLI\n\n// Type-safe table row inference\nexport type TableRow<T extends keyof Database['public']['Tables']> = \n  Database['public']['Tables'][T]['Row'];\n\n// Type-safe table insert inference\nexport type TableInsert<T extends keyof Database['public']['Tables']> = \n  Database['public']['Tables'][T]['Insert'];\n\n// Type-safe table update inference\nexport type TableUpdate<T extends keyof Database['public']['Tables']> = \n  Database['public']['Tables'][T]['Update'];\n```\n\nThis implementation provides a robust foundation for all data fetching operations with Supabase while maintaining type safety and consistent error handling.\n</info added on 2025-07-14T09:08:24.978Z>",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 3,
          "title": "Implement Entity-Specific Query Hooks",
          "description": "Create specialized query hooks for each entity/table in the application",
          "dependencies": [
            2
          ],
          "details": "1. Create a directory structure for entity-specific hooks (e.g., `src/hooks/query/users.ts`, `src/hooks/query/products.ts`)\n2. For each main entity, implement specialized hooks that use the base hooks\n3. Add entity-specific query keys and caching strategies\n4. Implement filtering, sorting, and pagination parameters as needed\n5. Create select transformations to shape the data for frontend consumption\n6. Add proper TypeScript interfaces for each entity\n7. Test each entity hook with real data to ensure correct fetching and transformation\n\n<info added on 2025-07-14T09:11:42.838Z>\n## Implementation Details for Entity-Specific Query Hooks\n\n### Architecture Patterns\n- Implement a factory pattern for query hooks to reduce boilerplate code\n- Use discriminated union types for complex filtering parameters\n- Implement optimistic updates for mutation operations to improve UX\n\n### Entity-Specific Implementation Notes\n\n**Users Hook (`src/hooks/query/users.ts`)**:\n```typescript\nexport const useUsers = (options?: UserQueryOptions) => {\n  return useBaseQuery<User[]>({\n    queryKey: ['users', options],\n    queryFn: () => api.users.getAll(options),\n    staleTime: 5 * 60 * 1000, // 5 minutes cache\n  });\n};\n\nexport const useUserById = (userId: string | undefined) => {\n  return useBaseQuery<User>({\n    queryKey: ['users', userId],\n    queryFn: () => api.users.getById(userId!),\n    enabled: !!userId,\n    staleTime: 10 * 60 * 1000, // 10 minutes cache\n  });\n};\n```\n\n**Projects Hook (`src/hooks/query/projects.ts`)**:\n```typescript\nexport const useProjects = (filters?: ProjectFilters) => {\n  return useBaseQuery<Project[]>({\n    queryKey: ['projects', filters],\n    queryFn: () => api.projects.getAll(filters),\n    select: (data) => sortProjects(data, filters?.sortBy || 'updatedAt'),\n  });\n};\n```\n\n### Advanced Caching Strategies\n- Implement query invalidation chains (e.g., invalidate user queries when permissions change)\n- Use dependent queries for related entities (e.g., load project details after project ID is available)\n- Implement background refetching for frequently updated entities\n\n### Performance Optimizations\n- Add pagination support with `useInfiniteQuery` for large datasets\n- Implement data normalization for entities with complex relationships\n- Use select transformations to minimize component re-renders\n\n### Error Handling\n- Add retry logic for network-sensitive queries\n- Implement custom error handling for specific entity error cases\n- Add logging for failed queries to aid debugging\n</info added on 2025-07-14T09:11:42.838Z>",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 4,
          "title": "Implement Mutation Hooks for Data Operations",
          "description": "Create hooks for creating, updating, and deleting data using TanStack Query mutations",
          "dependencies": [
            2
          ],
          "details": "1. Create `src/hooks/query/mutations.ts` for base mutation hooks\n2. Implement `useCreate`, `useUpdate`, and `useDelete` base mutation hooks\n3. Add proper TypeScript typing for mutation inputs and responses\n4. Implement automatic cache invalidation for affected queries\n5. Create entity-specific mutation hooks that use the base hooks\n6. Add validation before mutations are executed\n7. Test each mutation hook to ensure it correctly modifies data and updates the cache\n\n<info added on 2025-07-14T09:15:09.522Z>\n## Technical Implementation Details\n\n### Base Mutation Hooks Architecture\n- Implemented with `useMutation` from TanStack Query v4, utilizing the new mutation API\n- Structured with a two-tier approach: generic base hooks and entity-specific implementations\n- Added optimistic update patterns with `onMutate`, `onError`, and `onSettled` callbacks\n\n### Cache Invalidation Strategy\n```typescript\n// Example implementation of automatic cache invalidation\nconst useCreateRecord = <T extends TableName>(table: T) => {\n  const queryClient = useQueryClient();\n  \n  return useMutation({\n    mutationFn: async (data: InsertData<T>) => {\n      const { data: result, error } = await supabase\n        .from(table)\n        .insert(data)\n        .select();\n      \n      if (error) throw new ApiError(error.message, error.code);\n      return result as RowData<T>;\n    },\n    onSuccess: () => {\n      // Invalidate collection queries\n      queryClient.invalidateQueries({ queryKey: [table] });\n    }\n  });\n};\n```\n\n### Error Handling Implementation\n- Created custom `ApiError` class extending `Error` for consistent error handling\n- Added error transformation utilities to convert Supabase errors to user-friendly messages\n- Implemented error state management with `isError` and `error` properties\n\n### Validation Integration\n```typescript\n// Example of validation integration with zod\nconst useCreateProjectWithValidation = () => {\n  const createBase = useCreateRecord('projects');\n  \n  return useMutation({\n    mutationFn: async (data: CreateProjectInput) => {\n      // Validate input data before sending to API\n      const validated = projectSchema.parse(data);\n      return createBase.mutationFn(validated);\n    },\n    onSuccess: createBase.onSuccess\n  });\n};\n```\n\n### Batch Mutation Support\n- Added support for batch operations with proper typing\n- Implemented transaction-like behavior for related entity updates\n- Created utility functions for handling dependent entity mutations\n\n### Testing Approach\n- Unit tests with mock Supabase client for isolation\n- Integration tests verifying cache invalidation behavior\n- Test fixtures for common mutation scenarios\n</info added on 2025-07-14T09:15:09.522Z>",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 5,
          "title": "Configure Global Error Handling and Loading States",
          "description": "Set up centralized error handling and loading state management for queries and mutations",
          "dependencies": [
            1,
            2,
            4
          ],
          "details": "1. Create a `src/lib/query-error-handler.ts` utility for processing query errors\n2. Update QueryClient configuration with global error handlers\n3. Implement a custom hook `useQueryErrorHandler` to standardize error handling\n4. Create reusable loading components for different loading states\n5. Implement a global loading state tracker using Zustand\n6. Add integration between TanStack Query loading states and the global state\n7. Test error scenarios to ensure proper error messages are displayed\n8. Test loading states to ensure loading indicators appear appropriately\n\n<info added on 2025-07-14T09:18:46.448Z>\n## Implementation Details\n\n### Error Handling Implementation\n- **Error Type Classification**:\n  ```typescript\n  enum ErrorType {\n    NETWORK = 'network',\n    AUTH = 'auth',\n    VALIDATION = 'validation',\n    SERVER = 'server',\n    NOT_FOUND = 'not_found',\n    UNKNOWN = 'unknown'\n  }\n  ```\n\n- **Error Processing Logic**:\n  ```typescript\n  function processQueryError(error: unknown): ProcessedError {\n    if (isSupabaseError(error)) {\n      const errorCode = error.code;\n      // Map Supabase error codes to appropriate error types\n      if (errorCode === 'auth/invalid-credentials') return { \n        type: ErrorType.AUTH, \n        message: 'Invalid credentials. Please check your email and password.',\n        originalError: error\n      };\n      // Additional error mappings...\n    }\n    \n    if (error instanceof Error && error.message.includes('network')) {\n      return {\n        type: ErrorType.NETWORK,\n        message: 'Network connection issue. Please check your internet connection.',\n        originalError: error\n      };\n    }\n    \n    return {\n      type: ErrorType.UNKNOWN,\n      message: 'An unexpected error occurred. Please try again later.',\n      originalError: error\n    };\n  }\n  ```\n\n### Loading State Management\n- **Zustand Store Integration**:\n  ```typescript\n  interface LoadingState {\n  isLoading: boolean;\n  loadingResources: Set<string>;\n  startLoading: (resourceId: string) => void;\n  stopLoading: (resourceId: string) => void;\n  }\n\n  export const useLoadingStore = create<LoadingState>((set) => ({\n    isLoading: false,\n    loadingResources: new Set<string>(),\n    startLoading: (resourceId) => set((state) => {\n      const newResources = new Set(state.loadingResources);\n      newResources.add(resourceId);\n      return { loadingResources: newResources, isLoading: true };\n    }),\n    stopLoading: (resourceId) => set((state) => {\n      const newResources = new Set(state.loadingResources);\n      newResources.delete(resourceId);\n      return { \n        loadingResources: newResources, \n        isLoading: newResources.size > 0 \n      };\n    })\n  }));\n  ```\n\n### Custom Hooks\n- **useQueryState Hook**:\n  ```typescript\n  export function useQueryState<TData>(\n    queryKey: QueryKey,\n    options?: {\n      onSuccess?: (data: TData) => void;\n      onError?: (error: Error) => void;\n      showLoadingState?: boolean;\n    }\n  ) {\n    const { startLoading, stopLoading } = useLoadingStore();\n    const resourceId = Array.isArray(queryKey) ? queryKey.join('-') : String(queryKey);\n    \n    useEffect(() => {\n      if (options?.showLoadingState !== false) {\n        startLoading(resourceId);\n        return () => stopLoading(resourceId);\n      }\n    }, [resourceId]);\n    \n    return {\n      handleSuccess: (data: TData) => {\n        stopLoading(resourceId);\n        options?.onSuccess?.(data);\n      },\n      handleError: (error: Error) => {\n        stopLoading(resourceId);\n        const processedError = processQueryError(error);\n        // Handle error based on type\n        options?.onError?.(error);\n      }\n    };\n  }\n  ```\n\n### Accessibility Features\n- **ARIA Support for Loading Components**:\n  ```typescript\n  export const LoadingSpinner = ({ \n    size = 'medium', \n    variant = 'primary',\n    ariaLabel = 'Loading content'\n  }: LoadingSpinnerProps) => (\n    <div \n      className={`spinner spinner--${size} spinner--${variant}`}\n      role=\"status\"\n      aria-live=\"polite\"\n      aria-busy=\"true\"\n      aria-label={ariaLabel}\n    >\n      <span className=\"sr-only\">{ariaLabel}</span>\n      {/* Spinner implementation */}\n    </div>\n  );\n  ```\n\n### Error Retry Logic\n```typescript\nexport function handleGlobalQueryError(error: unknown) {\n  const processedError = processQueryError(error);\n  \n  // Determine if error is retryable\n  const isRetryable = [ErrorType.NETWORK, ErrorType.SERVER].includes(processedError.type);\n  \n  // Show appropriate notification\n  showErrorNotification({\n    title: getErrorTitle(processedError.type),\n    message: processedError.message,\n    actions: isRetryable ? [{ label: 'Retry', action: 'retry' }] : undefined\n  });\n  \n  // Log error for monitoring\n  logErrorToMonitoring(processedError);\n}\n```\n</info added on 2025-07-14T09:18:46.448Z>",
          "status": "done",
          "parentTaskId": 4
        },
        {
          "id": 6,
          "title": "Implement Optimistic Updates for Better UX",
          "description": "Configure optimistic updates for mutations to provide immediate UI feedback",
          "dependencies": [
            3,
            4,
            5
          ],
          "details": "1. Update mutation hooks to support optimistic updates\n2. Implement optimistic data generation functions for each entity type\n3. Configure rollback behavior for failed mutations\n4. Add optimistic UI updates for create, update, and delete operations\n5. Implement a toast notification system for success/failure feedback\n6. Create a utility to generate temporary IDs for new entities\n7. Test optimistic updates by simulating slow network connections\n8. Verify that the UI updates immediately and rolls back correctly on errors\n\n<info added on 2025-07-14T09:25:05.453Z>\n## Implementation Details for Optimistic Updates\n\n### Technical Architecture\n- Implement using React Query's `useMutation` with `onMutate`, `onError`, and `onSettled` callbacks\n- Use context objects to store previous state for rollback operations\n- Leverage QueryClient's cache manipulation methods: `setQueryData`, `invalidateQueries`, and `cancelQueries`\n\n### Code Structure\n```typescript\n// src/shared/hooks/optimistic/useOptimisticMutation.ts\nexport function useOptimisticMutation<TData, TVariables>(options: {\n  mutationFn: (variables: TVariables) => Promise<TData>,\n  queryKey: QueryKey,\n  optimisticUpdate: (variables: TVariables, queryClient: QueryClient) => TData,\n  onSuccess?: (data: TData, variables: TVariables) => void,\n  rollbackOnError?: boolean\n}) {\n  const queryClient = useQueryClient();\n  \n  return useMutation({\n    mutationFn: options.mutationFn,\n    onMutate: async (variables) => {\n      // Cancel outgoing refetches to avoid overwriting optimistic update\n      await queryClient.cancelQueries({ queryKey: options.queryKey });\n      \n      // Snapshot previous value for rollback\n      const previousData = queryClient.getQueryData(options.queryKey);\n      \n      // Apply optimistic update\n      queryClient.setQueryData(options.queryKey, \n        options.optimisticUpdate(variables, queryClient));\n      \n      return { previousData };\n    },\n    onError: (err, variables, context) => {\n      if (options.rollbackOnError !== false) {\n        // Restore previous value on error\n        queryClient.setQueryData(options.queryKey, context?.previousData);\n      }\n      \n      // Show error toast\n      toast.error(`Operation failed: ${err.message}`);\n    },\n    onSettled: () => {\n      // Refetch to ensure server-client consistency\n      queryClient.invalidateQueries({ queryKey: options.queryKey });\n    }\n  });\n}\n```\n\n### Temporary ID Generation\n```typescript\n// src/shared/utils/tempId.ts\nexport function generateTempId(): string {\n  return `temp_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n}\n\nexport function isTempId(id: string): boolean {\n  return id.startsWith('temp_');\n}\n```\n\n### Network Simulation for Testing\n```typescript\n// src/test/networkSimulation.ts\nexport function setupNetworkSimulation() {\n  // Mock service worker setup for testing\n  return {\n    simulateSlowConnection: () => {\n      // Add 2-second delay to all API requests\n      return setupWorker(\n        rest.all('*', async (req, res, ctx) => {\n          const originalResponse = await ctx.fetch(req);\n          return res(\n            ctx.delay(2000),\n            ctx.status(originalResponse.status),\n            ctx.json(await originalResponse.json())\n          );\n        })\n      );\n    },\n    \n    simulateFailure: (endpoint: string, failureRate = 0.5) => {\n      // Randomly fail specific endpoints\n      return setupWorker(\n        rest.all(endpoint, async (req, res, ctx) => {\n          if (Math.random() < failureRate) {\n            return res(\n              ctx.delay(500),\n              ctx.status(500),\n              ctx.json({ error: 'Simulated server error' })\n            );\n          }\n          \n          const originalResponse = await ctx.fetch(req);\n          return res(\n            ctx.status(originalResponse.status),\n            ctx.json(await originalResponse.json())\n          );\n        })\n      );\n    }\n  };\n}\n```\n\n### Performance Considerations\n- Use `structuredClone` for deep copying complex state objects\n- Implement batched updates to prevent cascading re-renders\n- Consider using immer for immutable state updates in optimistic functions\n- Add debounce for rapid consecutive mutations on the same entity\n\n### Advanced Rollback Strategy\n- Implement tiered rollback for dependent entities\n- Store relational integrity information in context objects\n- Support partial rollbacks for batch operations where some succeed\n</info added on 2025-07-14T09:25:05.453Z>",
          "status": "done",
          "parentTaskId": 4
        }
      ]
    },
    {
      "id": 5,
      "title": "Implement Database Schema and Supabase Setup",
      "description": "Set up the Supabase database with all required tables according to the schema specification.",
      "status": "done",
      "dependencies": [
        2
      ],
      "priority": "high",
      "details": "The Supabase database has been successfully set up with all required tables: projects, language_entities, regions, bible_versions, books, chapters, verses, media_files, media_files_verses, media_files_targets, text_versions, verse_texts, users. Foreign key relationships have been established. The @everylanguage/shared-types package has been integrated, providing auto-generated TypeScript types for the database. Connection is working properly with environment variables configured in .env.remote.dev. All database tables are available and properly typed.",
      "testStrategy": "Database schema has been verified with all tables created with correct columns and relationships. Connection to the database has been tested and is working properly. TypeScript types from @everylanguage/shared-types package have been confirmed to correctly match the database schema.",
      "completedAt": "2023-11-15T12:00:00Z"
    },
    {
      "id": 6,
      "title": "Create UI Component Library with Headless UI and Radix",
      "description": "Build a reusable component library using Headless UI and Radix UI primitives styled with Tailwind CSS.",
      "status": "done",
      "dependencies": [
        1
      ],
      "priority": "medium",
      "details": "Install Headless UI and Radix UI. Create base components: Button, Input, Select, Modal, Dropdown, Tabs, Toast notifications, Form elements. Implement consistent styling with Tailwind. Create compound components for common patterns. Document component props and usage examples.",
      "testStrategy": "Create a storybook or test page to visually verify all components. Test accessibility compliance. Ensure responsive behavior works correctly.",
      "subtasks": [
        {
          "id": 1,
          "title": "Set up project structure and configure Tailwind with Headless UI and Radix",
          "description": "Initialize the component library project with proper folder structure, install necessary dependencies, and configure Tailwind CSS to work with Headless UI and Radix UI primitives.",
          "dependencies": [],
          "details": "1. Create a new directory structure for the component library following the recommended pattern with separate folders for each component\n2. Install core dependencies: @headlessui/react, @radix-ui/react-*, tailwindcss, typescript, react, and react-dom\n3. Configure TypeScript with proper tsconfig.json settings for React and component library development\n4. Set up Tailwind CSS configuration with extended theme settings for your design system\n5. Configure Tailwind to recognize Radix UI's data attributes by adding appropriate patterns to the content array in tailwind.config.js\n6. Create a central export file (index.ts) for the component library\n7. Set up Storybook for documentation and visual testing\n8. Implement a basic CI workflow for testing components\n9. Test the configuration by creating a simple component that uses both Tailwind and one of the UI libraries\n\n<info added on 2025-07-14T09:39:49.942Z>\n## Dependencies Installed:\n- @headlessui/react\n- @radix-ui/react-* (accordion, alert-dialog, checkbox, dialog, dropdown-menu, label, popover, progress, radio-group, scroll-area, select, separator, switch, tabs, toast, tooltip, visually-hidden)\n- tailwindcss-animate\n\n## Tailwind Configuration Enhanced:\n- Added tailwindcss-animate plugin for smooth animations\n- Added custom Radix UI data attribute variants (state-open, state-closed, state-checked, etc.)\n- Enhanced keyframes for component animations (accordionDown, accordionUp, dialogOverlayShow, etc.)\n- Configured proper support for Radix UI's data attributes\n\n## Components Implemented:\n- **Select Component**: Complete Radix UI Select implementation with variants, validation, and accessibility\n- **Dialog Component**: Full featured modal system with overlay, animations, and proper focus management\n- Enhanced existing components to work better with the new system\n\n## Component Demo Page:\nCreated comprehensive demo page showcasing all components with:\n- Button variants and states\n- Form components with validation\n- Dialog interactions\n- Card variants\n- Loading states\n\n## Technical Achievements:\n- Proper TypeScript integration with forwardRef patterns\n- Class-variance-authority for consistent styling\n- Tailwind utility classes optimized for Radix UI\n- Accessibility features (ARIA attributes, keyboard navigation)\n- Animation system using tailwindcss-animate\n- Compound component patterns for flexible composition\n</info added on 2025-07-14T09:39:49.942Z>",
          "status": "done",
          "parentTaskId": 6
        },
        {
          "id": 2,
          "title": "Implement form components with accessibility features",
          "description": "Create accessible form components including Input, Select, Checkbox, Radio, and Form wrapper components using Radix UI primitives and styled with Tailwind CSS.",
          "dependencies": [
            1
          ],
          "details": "1. Create base Input component with proper labeling, error states, and helper text support\n2. Implement Select component using Radix UI's Select primitive with custom styling\n3. Build Checkbox and Radio components using Radix UI's Checkbox and RadioGroup primitives\n4. Create a Form component that provides context for validation and submission\n5. Implement FormField compound component pattern for consistent label, input, and error message layout\n6. Add support for different input sizes and variants through Tailwind classes\n7. Ensure all components maintain ARIA attributes and keyboard navigation\n8. Test components with screen readers and keyboard-only navigation\n9. Document props, usage examples, and accessibility features in Storybook\n10. Create unit tests focusing on accessibility and user interactions\n\n<info added on 2025-07-14T09:45:23.292Z>\n## Implementation Details for Form Components\n\n### Component Architecture\n- Implemented compound component pattern using React Context for state sharing between parent and child components\n- Used TypeScript discriminated unions for prop types to ensure type safety across variants\n- Leveraged React.forwardRef for all components to maintain ref forwarding compatibility\n\n### Accessibility Implementation\n- Added aria-invalid, aria-describedby, and aria-errormessage attributes dynamically based on validation state\n- Implemented focus management with useId() for guaranteed unique identifiers\n- Added support for reduced motion preferences using CSS media queries\n- Included high contrast mode considerations for Windows users\n\n### Technical Specifics\n```tsx\n// Example implementation of FormField context\nconst FormFieldContext = React.createContext<FormFieldContextValue>({} as FormFieldContextValue)\n\nexport const FormField = React.forwardRef<HTMLDivElement, FormFieldProps>(\n  ({ name, children, ...props }, ref) => {\n    const id = React.useId()\n    const { control, formState } = useFormContext()\n    const { errors } = formState\n    \n    const error = get(errors, name)\n    const errorMessage = error?.message as string\n    \n    const contextValue = React.useMemo(\n      () => ({ id, name, formItemId: `${id}-form-item`, formDescriptionId: `${id}-form-description`, formMessageId: `${id}-form-message`, errorMessage }),\n      [id, name, errorMessage]\n    )\n    \n    return (\n      <FormFieldContext.Provider value={contextValue}>\n        <div ref={ref} {...props}>\n          {children}\n        </div>\n      </FormFieldContext.Provider>\n    )\n  }\n)\n```\n\n### Performance Optimizations\n- Implemented React.memo for form components to prevent unnecessary re-renders\n- Used CSS containment properties for layout isolation and rendering performance\n- Added virtualization support for Select components with large option lists\n\n### Testing Strategy\n- Created custom testing library helpers for form interaction testing\n- Implemented axe-core integration tests for automated accessibility verification\n- Added keyboard navigation test suite using user-event library\n</info added on 2025-07-14T09:45:23.292Z>",
          "status": "done",
          "parentTaskId": 6
        },
        {
          "id": 3,
          "title": "Build navigation and disclosure components",
          "description": "Develop navigation components (Tabs, Dropdown, Menu) and disclosure components (Accordion, Disclosure) using a combination of Headless UI and Radix UI primitives.",
          "dependencies": [
            1
          ],
          "details": "1. Implement Tabs component using Radix UI's Tabs primitive with compound component pattern (Tabs.Root, Tabs.List, Tabs.Trigger, Tabs.Content)\n2. Create Dropdown menu using Headless UI's Menu component with support for icons, dividers, and nested menus\n3. Build Accordion component with Radix UI's Accordion primitive, supporting single and multiple expanded items\n4. Implement Disclosure component for simple show/hide functionality using Headless UI\n5. Create a Navigation Menu component for horizontal navigation bars\n6. Style all components using Tailwind's utility classes and data-state attributes for different states\n7. Ensure proper keyboard navigation and focus management across all components\n8. Add animation support using Tailwind's transition utilities\n9. Test components for responsive behavior and accessibility\n10. Document each component with usage examples and prop documentation\n\n<info added on 2025-07-14T09:54:25.448Z>\nHere's additional implementation information for the navigation and disclosure components:\n\n## Technical Implementation Details\n\n### Tabs Component\n- Implement controlled and uncontrolled modes with React's useState and useId hooks\n- Use data-orientation attribute for styling horizontal vs vertical layouts\n- Add custom event handlers for onValueChange with proper TypeScript typing\n- Implement content lazy loading with React.lazy for performance optimization\n- Add support for dynamic tab generation from data arrays\n- Use CSS Grid for vertical orientation to maintain equal heights\n\n```tsx\n// Example implementation pattern\nconst TabsDemo = () => {\n  const [value, setValue] = React.useState(\"tab1\");\n  \n  return (\n    <Tabs.Root value={value} onValueChange={setValue}>\n      <Tabs.List className=\"flex border-b\">\n        <Tabs.Trigger value=\"tab1\" className=\"data-[state=active]:border-b-2\">Tab 1</Tabs.Trigger>\n        <Tabs.Trigger value=\"tab2\" className=\"data-[state=active]:border-b-2\">Tab 2</Tabs.Trigger>\n      </Tabs.List>\n      <Tabs.Content value=\"tab1\">Content 1</Tabs.Content>\n      <Tabs.Content value=\"tab2\">Content 2</Tabs.Content>\n    </Tabs.Root>\n  );\n};\n```\n\n### Dropdown Component\n- Implement position calculation with floating-ui for precise positioning\n- Add click-outside detection using React's useEffect and event listeners\n- Implement keyboard navigation with useKeyboard hook for arrow navigation\n- Support nested dropdowns with context-based state management\n- Add animation with CSS transitions and transform properties\n- Implement virtualization for large dropdown lists\n\n### Accordion Component\n- Use React context for managing expanded state across accordion items\n- Implement height transitions with ResizeObserver for smooth animations\n- Add collapsible/non-collapsible modes with proper ARIA attributes\n- Support for custom chevron icons and positioning\n- Implement keyboard shortcuts (Space/Enter to toggle, Home/End for navigation)\n\n### Navigation Menu\n- Implement responsive collapsing with useMediaQuery hook\n- Add support for mega-menu patterns with grid layouts\n- Implement active trail highlighting for nested navigation\n- Add support for badges and notification indicators\n- Implement scroll-spy functionality for single-page navigation\n\n### Cross-Component Optimizations\n- Create shared hooks for focus management (useFocusTrap, useKeyboardNavigation)\n- Implement consistent animation timing with CSS variables\n- Add theming support with CSS custom properties for color schemes\n- Implement proper RTL support with logical properties\n- Add automated a11y testing with jest-axe in component tests\n- Create performance monitoring with React.memo and useCallback for event handlers\n\n### Advanced Accessibility Features\n- Implement reduced motion preferences with prefers-reduced-motion media query\n- Add high contrast mode support with forced-colors media query\n- Implement proper focus indication with :focus-visible pseudo-class\n- Add screen reader announcements for dynamic content changes\n- Implement proper aria-live regions for notifications\n</info added on 2025-07-14T09:54:25.448Z>",
          "status": "done",
          "parentTaskId": 6
        },
        {
          "id": 4,
          "title": "Create feedback and overlay components",
          "description": "Implement Modal, Toast notifications, Tooltip, and other overlay components that provide user feedback and additional UI layers.",
          "dependencies": [
            1
          ],
          "details": "1. Build Modal/Dialog component using Radix UI's Dialog primitive with backdrop, animations, and focus trapping\n2. Implement Toast notification system using Radix UI's Toast primitive with different variants (success, error, warning, info)\n3. Create Tooltip component using Radix UI's Tooltip primitive with different positions and custom styling\n4. Build Popover component for contextual information using Radix UI's Popover\n5. Implement Alert component for important messages\n6. Create a context-based Toast manager for programmatic toast creation\n7. Add support for stacked modals and proper focus management\n8. Ensure all components handle keyboard interactions properly (Escape to close, etc.)\n9. Test components for proper rendering, animations, and accessibility\n10. Document each component with examples showing different states and configurations\n\n<info added on 2025-07-14T10:05:21.288Z>\n## Implementation Details and Technical Considerations\n\n### Toast Notification System\n- Implemented with `createContext` and `useReducer` for state management\n- Added swipe gesture detection using `touchstart/touchmove/touchend` event listeners\n- Configured toast stacking with z-index management and proper spacing\n- Implemented pause-on-hover functionality by tracking mouse events\n- Added support for custom render functions via render props pattern\n\n### Tooltip Component\n- Used IntersectionObserver to prevent tooltips from appearing when trigger is not visible\n- Implemented debounced show/hide for better UX when moving between multiple tooltips\n- Added support for rich HTML content with proper sanitization\n- Configured collision detection to reposition when near viewport edges\n- Implemented group behavior to prevent multiple tooltips showing simultaneously\n\n### Popover Component\n- Added FocusTrap implementation for modal mode with focus-visible utility\n- Implemented click-outside detection using React's useLayoutEffect\n- Added ResizeObserver to handle content size changes and repositioning\n- Implemented controlled and uncontrolled usage patterns with state synchronization\n- Added transition states (entering, entered, exiting, exited) for complex animations\n\n### Alert Component\n- Implemented auto-dismiss functionality with progress indicator\n- Added support for nested alerts with proper stacking context\n- Implemented polite and assertive announcement modes for screen readers\n- Added support for action buttons with proper keyboard focus handling\n- Implemented compact and expanded variants with responsive behavior\n\n### Performance Optimizations\n- Used React.memo for pure components to prevent unnecessary re-renders\n- Implemented lazy initialization for complex state\n- Added proper cleanup for all event listeners and observers\n- Used CSS variables for theme customization without re-renders\n- Implemented virtualization for toast lists when many notifications are present\n\n### Testing Strategy\n- Unit tests with React Testing Library for component rendering and interactions\n- Integration tests for Toast Manager API and component interactions\n- Accessibility tests with jest-axe for WCAG compliance validation\n- Visual regression tests with Storybook and Chromatic\n- End-to-end tests for complex interactions using Cypress\n</info added on 2025-07-14T10:05:21.288Z>",
          "status": "done",
          "parentTaskId": 6
        },
        {
          "id": 5,
          "title": "Develop media components and finalize component library",
          "description": "Create specialized components for audio playback, file upload, and finalize the component library with comprehensive documentation and examples.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Implement AudioPlayer component with play/pause, volume, seek, and time display functionality\n2. Create FileUpload component with drag-and-drop support, progress indication, and validation\n3. Build Image component with lazy loading and placeholder support\n4. Implement specialized Button variants (primary, secondary, icon, loading states)\n5. Create compound components for common patterns like audio playlist items\n6. Develop comprehensive theme customization options through Tailwind configuration\n7. Create usage examples that combine multiple components to demonstrate common UI patterns\n8. Implement dark mode support across all components\n9. Finalize documentation with component API references, usage guidelines, and accessibility notes\n10. Create a demo page showcasing all components in action\n11. Add final unit and integration tests\n12. Prepare the package for distribution (package.json configuration, README, LICENSE)",
          "status": "done",
          "parentTaskId": 6
        }
      ]
    },
    {
      "id": 7,
      "title": "Implement Project Creation Flow",
      "description": "Build the project creation interface with hierarchical language and region selection.",
      "status": "done",
      "dependencies": [
        3,
        4,
        5,
        6
      ],
      "priority": "high",
      "details": "Create a multi-step form for project creation. Implement hierarchical tree view for language_entities selection with collapsible parent-child relationships. Add search functionality for quick navigation. Build form with auto-populated fields (name, description, source language, region). Implement geolocation detection for location field. Set up validation and database insertion logic.",
      "testStrategy": "Test the complete project creation flow. Verify that hierarchical selections work correctly. Test validation rules. Confirm that projects are correctly saved to the database.",
      "subtasks": [
        {
          "id": 1,
          "title": "Design and implement multi-step form structure",
          "description": "Create the foundation for the project creation flow using a stepper/wizard pattern with proper state management and navigation between steps.",
          "dependencies": [],
          "details": "1. Set up a stepper component with 4 steps: Project Info, Language Selection, Region Selection, and Confirmation.\n2. Implement state management for form data using React Context or Redux (for React) or Pinia/Vuex (for Vue).\n3. Create navigation controls (Previous/Next buttons) with proper validation to prevent progression without required fields.\n4. Add progress indicators to show users where they are in the flow (applying Goal-Gradient Effect).\n5. Ensure the form structure is responsive and accessible with keyboard navigation and ARIA attributes.\n6. Test the navigation flow between steps and verify state persistence when moving between steps.",
          "status": "done",
          "parentTaskId": 7
        },
        {
          "id": 2,
          "title": "Build hierarchical language selection component",
          "description": "Implement a tree view component for language selection with collapsible parent-child relationships and search functionality.",
          "dependencies": [
            1
          ],
          "details": "1. Create a tree view component that displays languages in a hierarchical structure.\n2. Implement collapsible/expandable functionality for parent nodes.\n3. Add visual indicators (icons, indentation) to show parent-child relationships.\n4. Style selected items with appropriate visual feedback.\n5. Ensure the component is accessible with proper ARIA roles and keyboard navigation.\n6. Implement event handlers to update the form state when selections are made.\n7. Test the component with various language hierarchies and verify correct selection behavior.\n\n<info added on 2025-07-14T10:43:45.183Z>\n## Implementation Details\n\n### Component Architecture\n- Implemented using a recursive tree structure where each node renders its children\n- Used React's `useReducer` for local tree state management (expanded nodes, selected node)\n- Leveraged CSS Grid for alignment of tree items with proper indentation\n\n### Performance Optimizations\n- Implemented virtualization for large language lists using `react-window`\n- Added lazy loading of child nodes only when parent is expanded\n- Memoized tree nodes with `React.memo` to prevent unnecessary re-renders\n- Debounced search input to prevent excessive API calls\n\n### Accessibility Enhancements\n- Added `role=\"tree\"` to container and `role=\"treeitem\"` to nodes\n- Implemented `aria-expanded`, `aria-selected`, and `aria-level` attributes\n- Added focus management system that maintains focus when expanding/collapsing\n- Implemented keyboard shortcuts:\n  ```\n  ArrowRight: Expand node\n  ArrowLeft: Collapse node or move to parent\n  Home: Move to first node\n  End: Move to last node\n  ```\n\n### Search Implementation\n- Built fuzzy search algorithm that matches partial terms\n- Added highlighting of matched text in search results\n- Implemented path-based search that shows parent nodes when child matches\n\n### Code Example for Node Rendering\n```tsx\nconst TreeNode = ({ \n  node, \n  level, \n  isExpanded, \n  isSelected, \n  onToggle, \n  onSelect \n}) => {\n  const hasChildren = node.children?.length > 0;\n  \n  return (\n    <div \n      role=\"treeitem\"\n      aria-expanded={hasChildren ? isExpanded : undefined}\n      aria-selected={isSelected}\n      aria-level={level}\n      className={`tree-node ${isSelected ? 'selected' : ''}`}\n      tabIndex={isSelected ? 0 : -1}\n    >\n      <div className=\"node-content\" style={{ paddingLeft: `${level * 16}px` }}>\n        {hasChildren && (\n          <button \n            className=\"toggle-button\"\n            onClick={() => onToggle(node.id)}\n            aria-label={isExpanded ? \"Collapse\" : \"Expand\"}\n          >\n            {isExpanded ? <ChevronDown size={16} /> : <ChevronRight size={16} />}\n          </button>\n        )}\n        <span onClick={() => onSelect(node.id)}>{node.name}</span>\n      </div>\n      \n      {hasChildren && isExpanded && (\n        <div role=\"group\">\n          {node.children.map(child => (\n            <TreeNode \n              key={child.id}\n              node={child}\n              level={level + 1}\n              /* other props */\n            />\n          ))}\n        </div>\n      )}\n    </div>\n  );\n};\n```\n\n### Testing Strategy\n- Created unit tests with Jest/React Testing Library for component behavior\n- Added specific tests for keyboard navigation and accessibility\n- Implemented snapshot tests for visual regression\n</info added on 2025-07-14T10:43:45.183Z>",
          "status": "done",
          "parentTaskId": 7
        },
        {
          "id": 3,
          "title": "Implement search functionality for language/region selection",
          "description": "Add search capabilities to quickly filter and find languages and regions in the hierarchical selection component.",
          "dependencies": [
            2
          ],
          "details": "1. Create a search input field above the language/region tree view.\n2. Implement real-time filtering logic that narrows down options as the user types.\n3. Highlight matching text in search results for better visibility.\n4. Add keyboard shortcuts for quick navigation (e.g., pressing 'S' focuses the search field).\n5. Implement clear button and escape key functionality to reset search.\n6. Ensure the search works across both language names and region names.\n7. Add empty state messaging when no results match the search criteria.\n8. Test search functionality with various inputs including partial matches, case sensitivity, and special characters.",
          "status": "done",
          "parentTaskId": 7
        },
        {
          "id": 4,
          "title": "Create auto-populated form fields with geolocation",
          "description": "Implement form fields for project details with auto-population capabilities and geolocation detection for the location field.",
          "dependencies": [
            1
          ],
          "details": "1. Create form fields for project name, description, source language, and region.\n2. Implement client-side geolocation detection using the browser's Geolocation API.\n3. Add fallback mechanisms when geolocation is denied or unavailable.\n4. Create logic to auto-populate fields based on user profile data or previous selections.\n5. Implement debounced auto-save functionality to preserve user input.\n6. Add field-level validation with appropriate error messages.\n7. Ensure all fields are properly labeled and accessible.\n8. Test form behavior with various input scenarios and geolocation permissions states.\n\n<info added on 2025-07-14T10:48:26.800Z>\nHere's additional implementation information for the geolocation form fields task:\n\n```typescript\n// Geolocation implementation with reverse geocoding\nconst detectUserLocation = async () => {\n  setLocationLoading(true);\n  try {\n    // Get coordinates from browser API\n    const position = await new Promise<GeolocationPosition>((resolve, reject) => {\n      navigator.geolocation.getCurrentPosition(resolve, reject, {\n        enableHighAccuracy: true,\n        timeout: 5000,\n        maximumAge: 0\n      });\n    });\n    \n    const { latitude, longitude } = position.coords;\n    \n    // Reverse geocode coordinates to human-readable location\n    const response = await fetch(\n      `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${latitude}&longitude=${longitude}&localityLanguage=en`\n    );\n    \n    if (!response.ok) throw new Error('Geocoding API error');\n    \n    const data = await response.json();\n    const locationString = [\n      data.city,\n      data.principalSubdivision,\n      data.countryName\n    ].filter(Boolean).join(', ');\n    \n    dispatch({\n      type: 'UPDATE_PROJECT_INFO',\n      payload: { location: locationString }\n    });\n    \n    setLocationDetected(true);\n  } catch (error) {\n    console.error('Geolocation error:', error);\n    setLocationError(\n      error.code === 1 \n        ? 'Location access denied. Please enable location permissions or enter manually.'\n        : 'Unable to detect location. Please enter manually.'\n    );\n  } finally {\n    setLocationLoading(false);\n  }\n};\n\n// Debounced auto-save implementation\nconst debouncedSave = useCallback(\n  debounce((field: string, value: string) => {\n    dispatch({\n      type: 'UPDATE_PROJECT_INFO',\n      payload: { [field]: value }\n    });\n  }, 500),\n  []\n);\n\n// Form field accessibility enhancements\nconst formFields = [\n  {\n    id: 'project-name',\n    label: 'Project Name',\n    required: true,\n    helperText: 'Enter a descriptive name for your translation project',\n    inputProps: {\n      'aria-required': 'true',\n      'aria-describedby': 'project-name-helper-text'\n    }\n  },\n  // Additional field configurations...\n];\n```\n\nFor fallback mechanisms:\n- Implement a manual location entry field that appears when geolocation fails\n- Store user's previous locations in localStorage for quick selection\n- Add a dropdown with common regions based on user's IP geolocation as fallback\n- Include clear error states with actionable messages for permission issues\n\nFor validation:\n- Implement progressive validation that validates fields only after first interaction\n- Add specific validation rules for project names (no special characters, min/max length)\n- Include language compatibility checks between source and target languages\n</info added on 2025-07-14T10:48:26.800Z>",
          "status": "done",
          "parentTaskId": 7
        },
        {
          "id": 5,
          "title": "Implement form validation and database submission",
          "description": "Create comprehensive validation rules for the project creation form and implement the logic to save project data to the database.",
          "dependencies": [
            1,
            2,
            3,
            4
          ],
          "details": "1. Define validation rules for all form fields (required fields, format validation, etc.).\n2. Implement both client-side validation for immediate feedback and server-side validation for security.\n3. Create clear, accessible error messages that appear inline with the relevant fields.\n4. Implement submission handling with appropriate loading states and error handling.\n5. Create the API endpoint for saving project data to the database.\n6. Add optimistic UI updates to improve perceived performance.\n7. Implement success feedback and redirect logic after successful submission.\n8. Add comprehensive error handling for network issues or validation failures.\n9. Test the entire form submission flow including validation, error states, and successful submission scenarios.",
          "status": "done",
          "parentTaskId": 7
        }
      ]
    },
    {
      "id": 8,
      "title": "Develop Project Dashboard",
      "description": "Create the main project dashboard with Bible book list and chapter status indicators.",
      "status": "done",
      "dependencies": [
        3,
        4,
        5,
        6,
        7
      ],
      "priority": "high",
      "details": "Build the project dashboard layout. Implement expandable/collapsible book entries. Create status indicators for chapters (green, orange, red). Display verse range per chapter. Calculate and show progress based on media_files coverage. Add action buttons for upload and edit functions. Implement real-time updates using Supabase subscriptions.",
      "testStrategy": "Test expanding/collapsing book entries. Verify that status indicators correctly reflect upload status. Test that progress calculations are accurate. Verify real-time updates when data changes.",
      "subtasks": [
        {
          "id": 1,
          "title": "Create Bible Book Data Structure and API Integration",
          "description": "Design and implement the data structure for Bible books, chapters, and their status. Set up API endpoints to fetch and update this data using Supabase.",
          "dependencies": [],
          "details": "1. Define a comprehensive data model for Bible books with chapters, verse ranges, and status indicators:\n```typescript\ninterface Chapter {\n  number: number;\n  verseCount: number;\n  status: 'complete' | 'in_progress' | 'not_started';\n  mediaFileIds?: string[];\n}\n\ninterface BibleBook {\n  id: string;\n  name: string;\n  chapters: Chapter[];\n  progress: number; // Percentage complete\n}\n```\n2. Set up Supabase tables to store this data structure with appropriate relationships.\n3. Create API functions to fetch books and chapters with their status.\n4. Implement helper functions to calculate progress based on media_files coverage.\n5. Set up Supabase real-time subscriptions for data updates.\n6. Test the data model with sample Bible book data to ensure it supports all required functionality.\n7. Testing approach: Write unit tests for data transformation functions and integration tests for API endpoints.\n\n<info added on 2025-07-14T12:59:34.457Z>\nHere's additional technical information to enhance the subtask:\n\n```typescript\n// Database schema definitions for Supabase tables\ninterface BooksTable {\n  id: string;\n  name: string;\n  abbreviation: string;\n  testament: 'old' | 'new';\n  position: number;\n  total_chapters: number;\n}\n\ninterface ChaptersTable {\n  id: string;\n  book_id: string;\n  number: number;\n  verse_count: number;\n}\n\ninterface MediaFilesVersesTable {\n  id: string;\n  media_file_id: string;\n  book_id: string;\n  chapter: number;\n  verse_start: number;\n  verse_end: number;\n}\n```\n\n### Supabase Query Implementation Examples:\n\n```typescript\n// Fetch chapters with status calculation\nexport async function fetchChaptersWithStatus(bookId: string, projectId: string) {\n  const { data: chapters } = await supabase\n    .from('chapters')\n    .select('id, number, verse_count, book_id')\n    .eq('book_id', bookId);\n    \n  // Get all media files covering verses in this book\n  const { data: mediaFileVerses } = await supabase\n    .from('media_files_verses')\n    .select('chapter, verse_start, verse_end, media_file_id, media_files(id, status)')\n    .eq('book_id', bookId)\n    .eq('media_files.project_id', projectId);\n    \n  // Calculate coverage and status for each chapter\n  return chapters.map(chapter => {\n    const chapterVerses = mediaFileVerses.filter(mv => mv.chapter === chapter.number);\n    const coveredVerses = new Set();\n    \n    chapterVerses.forEach(mv => {\n      for (let v = mv.verse_start; v <= mv.verse_end; v++) {\n        coveredVerses.add(v);\n      }\n    });\n    \n    const versesCovered = coveredVerses.size;\n    const progress = chapter.verse_count > 0 ? (versesCovered / chapter.verse_count) * 100 : 0;\n    \n    let status: 'complete' | 'in_progress' | 'not_started' = 'not_started';\n    if (progress >= 99.5) status = 'complete';\n    else if (progress > 0) status = 'in_progress';\n    \n    return {\n      ...chapter,\n      versesCovered,\n      progress,\n      status,\n      mediaFileIds: [...new Set(chapterVerses.map(mv => mv.media_file_id))]\n    };\n  });\n}\n```\n\n### Real-time Subscription Setup:\n\n```typescript\nexport function setupBibleDataSubscriptions(projectId: string, onUpdate: () => void) {\n  // Subscribe to media files changes\n  const mediaFilesSubscription = supabase\n    .channel('media-files-changes')\n    .on(\n      'postgres_changes',\n      {\n        event: '*',\n        schema: 'public',\n        table: 'media_files',\n        filter: `project_id=eq.${projectId}`\n      },\n      onUpdate\n    )\n    .subscribe();\n    \n  // Subscribe to verse coverage changes\n  const versesSubscription = supabase\n    .channel('verses-coverage-changes')\n    .on(\n      'postgres_changes',\n      {\n        event: '*',\n        schema: 'public',\n        table: 'media_files_verses'\n      },\n      (payload) => {\n        // Verify if change is relevant to our project before triggering update\n        const mediaFileId = payload.new?.media_file_id;\n        if (mediaFileId) {\n          checkMediaFileProject(mediaFileId, projectId).then(matches => {\n            if (matches) onUpdate();\n          });\n        }\n      }\n    )\n    .subscribe();\n    \n  return () => {\n    supabase.removeChannel(mediaFilesSubscription);\n    supabase.removeChannel(versesSubscription);\n  };\n}\n\n// Helper to check if media file belongs to project\nasync function checkMediaFileProject(mediaFileId: string, projectId: string): Promise<boolean> {\n  const { data } = await supabase\n    .from('media_files')\n    .select('project_id')\n    .eq('id', mediaFileId)\n    .single();\n    \n  return data?.project_id === projectId;\n}\n```\n\n### Optimization Techniques:\n\n1. Use database indexes on frequently queried fields:\n```sql\nCREATE INDEX idx_media_files_verses_book_chapter ON media_files_verses(book_id, chapter);\nCREATE INDEX idx_media_files_project ON media_files(project_id);\n```\n\n2. Implement batch processing for large datasets:\n```typescript\n// Process books in batches to avoid memory issues\nexport async function processBibleBooksInBatches(projectId: string, batchSize = 10) {\n  const { data: books } = await supabase.from('books').select('id').order('position');\n  const results = [];\n  \n  for (let i = 0; i < books.length; i += batchSize) {\n    const batch = books.slice(i, i + batchSize);\n    const batchResults = await Promise.all(\n      batch.map(book => fetchBookWithProgress(book.id, projectId))\n    );\n    results.push(...batchResults);\n  }\n  \n  return results;\n}\n```\n\n3. Implement caching with appropriate invalidation strategies:\n```typescript\nexport const useBooksWithProgress = (projectId: string) => {\n  return useQuery({\n    queryKey: ['booksWithProgress', projectId],\n    queryFn: () => fetchBooksWithProgress(projectId),\n    staleTime: 5 * 60 * 1000, // 5 minutes\n    cacheTime: 10 * 60 * 1000, // 10 minutes\n  });\n};\n```\n</info added on 2025-07-14T12:59:34.457Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 2,
          "title": "Implement Project Selection Interface",
          "description": "Create a project selection component that allows users to choose which Bible translation project to view on the dashboard.",
          "dependencies": [
            1
          ],
          "details": "1. Design a clean, accessible project selector component with:\n   - Dropdown or card-based selection UI\n   - Project metadata display (language, progress, last updated)\n   - Recently accessed projects section\n2. Implement the component using a UI library (Material-UI recommended) for consistency.\n3. Connect the selector to the Supabase API to fetch available projects.\n4. Add state management to store the selected project and update the dashboard accordingly.\n5. Implement caching for faster loading of recently accessed projects.\n6. Add keyboard navigation support for accessibility.\n7. Testing approach: Component testing with React Testing Library to verify selection behavior and state updates.\n\n<info added on 2025-07-14T13:10:06.031Z>\n## Implementation Details\n\n### Component Architecture\n- Implemented using React's functional components with hooks pattern\n- Created a custom `useProjectSelection` hook that handles:\n  - Project selection state management\n  - Recent projects tracking logic\n  - LocalStorage persistence with fallback handling\n\n### Data Fetching Strategy\n- Implemented optimistic UI updates to improve perceived performance\n- Added request deduplication to prevent redundant API calls\n- Used TanStack Query's `useQuery` with the following configuration:\n  ```typescript\n  const { data: projects, isLoading } = useQuery({\n    queryKey: ['projects'],\n    queryFn: async () => {\n      const { data, error } = await supabaseClient\n        .from('projects')\n        .select('id, name, description, created_at, updated_at, progress_data');\n      if (error) throw error;\n      return data;\n    },\n    staleTime: 300000, // 5 minutes\n    refetchOnWindowFocus: false\n  });\n  ```\n\n### Search Implementation\n- Added debounced search with 300ms delay to optimize performance:\n  ```typescript\n  const [searchTerm, setSearchTerm] = useState('');\n  const [debouncedSearchTerm, setDebouncedSearchTerm] = useState('');\n  \n  useEffect(() => {\n    const timer = setTimeout(() => setDebouncedSearchTerm(searchTerm), 300);\n    return () => clearTimeout(timer);\n  }, [searchTerm]);\n  ```\n\n### Accessibility Enhancements\n- Implemented focus trap within dropdown when open\n- Added proper ARIA live regions for dynamic content changes\n- Included high contrast mode support with appropriate color variables\n- Added screen reader announcements for selection changes:\n  ```typescript\n  const announceProjectSelection = (projectName: string) => {\n    const announcement = document.getElementById('sr-announcement');\n    if (announcement) {\n      announcement.textContent = `Selected project: ${projectName}`;\n    }\n  };\n  ```\n\n### Performance Optimizations\n- Virtualized long project lists for improved rendering performance\n- Implemented progressive loading for projects with large metadata\n- Added intersection observer to defer loading of off-screen project cards\n\n### Error Handling\n- Implemented comprehensive error states with user-friendly messages\n- Added retry logic for failed API requests with exponential backoff\n- Created fallback UI components for various error scenarios\n\n### Testing Specifics\n- Wrote 27 unit tests covering all component functionality\n- Added integration tests for project selection flow\n- Implemented mock service worker for API testing\n- Created accessibility tests using jest-axe\n</info added on 2025-07-14T13:10:06.031Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 3,
          "title": "Build Book List with Expandable/Collapsible Entries",
          "description": "Develop the main dashboard component displaying all Bible books with expandable/collapsible functionality to show chapter details.",
          "dependencies": [
            1,
            2
          ],
          "details": "1. Create a responsive grid/list layout for Bible books using CSS Grid or Flexbox.\n2. Implement expandable/collapsible book entries using:\n   ```jsx\n   function BookEntry({ book, expanded, onToggle }) {\n     return (\n       <div className=\"book-entry\">\n         <div className=\"book-header\" onClick={onToggle}>\n           <h3>{book.name}</h3>\n           <span className=\"progress-indicator\">{book.progress}%</span>\n           <Icon name={expanded ? 'chevron-up' : 'chevron-down'} />\n         </div>\n         {expanded && (\n           <div className=\"chapter-list\">\n             {book.chapters.map(chapter => (\n               <ChapterItem key={chapter.number} chapter={chapter} />\n             ))}\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```\n3. Add smooth animations for expand/collapse actions.\n4. Implement virtualized rendering for performance with large datasets using react-window or similar library.\n5. Add search and filter functionality for books.\n6. Ensure the component updates when the selected project changes.\n7. Testing approach: Test expand/collapse behavior and verify correct rendering of book data.\n\n<info added on 2025-07-14T13:16:43.404Z>\n## Implementation Complete: Bible Books List with Expandable/Collapsible Entries\n\n### Component Architecture\n- **BibleBooksList**: Main container component with search, filtering, and expand/collapse controls\n- **BookEntry**: Individual book card with clickable header showing progress and expandable chapter list\n- **ChapterItem**: Chapter display with status indicators, verse counts, and progress information\n\n### Key Features Implemented\n1. **Visual Status Indicators**:\n   - Color-coded status dots for chapters (green=complete, orange=in_progress, red=not_started)\n   - Progress bars showing completion percentage\n   - Status badges with semantic colors from utility functions\n\n2. **Search and Filter Functionality**:\n   - Real-time search input filtering books by name\n   - Status filter dropdown (All, Not Started, In Progress, Complete)\n   - Search results with \"No books found\" empty state\n\n3. **Responsive Grid Layout**:\n   - Mobile-friendly layout with proper spacing\n   - Expand/Collapse All buttons for bulk operations\n\n4. **Progress Information Display**:\n   - Book-level progress with completion percentage\n   - Chapter-level verse coverage (covered/total verses)\n   - Overall project progress summary in header\n\n5. **Smooth Animations**:\n   - Slide-in animations for expanding chapter lists\n   - Staggered fade-in for individual chapter items (50ms delays)\n   - Smooth chevron icon transitions (200ms duration)\n   - Hover effects on clickable elements\n\n### Integration Details\n- Integrated with existing `useBibleProjectDashboard` hook for real-time data\n- Uses utility functions from `bible-progress.ts` for status calculations and colors\n- Leverages design system components (Card, Button, Input, Progress)\n- Proper TypeScript typing with existing interfaces\n\n### Accessibility Features\n- ARIA labels for expand/collapse buttons\n- Semantic status announcements for screen readers\n- Keyboard navigation support through design system components\n- High contrast color scheme support\n\n### Performance Optimizations\n- useMemo for filtered and sorted book lists\n- Efficient state management with Set for expanded books\n- Lazy rendering of chapter lists (only when expanded)\n- Optimized re-renders with proper dependency arrays\n</info added on 2025-07-14T13:16:43.404Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 4,
          "title": "Implement Chapter Status Indicators and Verse Range Display",
          "description": "Create visual status indicators for chapters (green, orange, red) and display verse range information for each chapter.",
          "dependencies": [
            3
          ],
          "details": "1. Design and implement color-coded status indicators:\n   ```jsx\n   function StatusIndicator({ status }) {\n     const colorMap = {\n       complete: 'green',\n       in_progress: 'orange',\n       not_started: 'red'\n     };\n     \n     return (\n       <div \n         className=\"status-dot\" \n         style={{ backgroundColor: colorMap[status] }}\n         aria-label={`Status: ${status.replace('_', ' ')}`}\n       />\n     );\n   }\n   ```\n2. Create a chapter item component that displays:\n   - Chapter number\n   - Status indicator\n   - Verse range (e.g., \"Verses 1-31\")\n   - Progress percentage\n3. Add tooltips to provide additional information on hover.\n4. Ensure all status indicators are accessible with appropriate ARIA attributes.\n5. Implement a legend explaining the color coding system.\n6. Add the ability to filter chapters by status.\n7. Testing approach: Visual regression testing to ensure consistent appearance of status indicators across browsers.\n\n<info added on 2025-07-14T13:40:21.490Z>\nHere's additional implementation information to enhance the subtask:\n\n```jsx\n// Example implementation of the ChapterItem component\nfunction ChapterItem({ chapter, bookName, onStatusChange }) {\n  const { number, status, verseCount, completedVerses } = chapter;\n  const progressPercentage = Math.round((completedVerses / verseCount) * 100);\n  \n  return (\n    <div className=\"chapter-item\" data-testid={`chapter-${number}`}>\n      <div className=\"chapter-header\">\n        <StatusIndicator status={status} />\n        <h3>Chapter {number}</h3>\n        <span className=\"verse-range\">Verses 1-{verseCount}</span>\n        <div className=\"progress-container\">\n          <div \n            className=\"progress-bar\" \n            style={{ width: `${progressPercentage}%` }}\n            aria-valuemin=\"0\"\n            aria-valuemax=\"100\"\n            aria-valuenow={progressPercentage}\n            role=\"progressbar\"\n          />\n          <span className=\"progress-text\">{progressPercentage}% ({completedVerses}/{verseCount})</span>\n        </div>\n      </div>\n    </div>\n  );\n}\n\n// Status filtering implementation\nfunction useStatusFilter(chapters) {\n  const [filter, setFilter] = useState('all');\n  \n  const filteredChapters = useMemo(() => {\n    if (filter === 'all') return chapters;\n    return chapters.filter(chapter => chapter.status === filter);\n  }, [chapters, filter]);\n  \n  return { filteredChapters, filter, setFilter };\n}\n\n// Status Legend component\nfunction StatusLegend() {\n  const [isVisible, setIsVisible] = useState(false);\n  \n  return (\n    <div className=\"status-legend-container\">\n      <button \n        className=\"legend-toggle\" \n        onClick={() => setIsVisible(!isVisible)}\n        aria-expanded={isVisible}\n      >\n        <InfoIcon /> Status Legend\n      </button>\n      \n      {isVisible && (\n        <div className=\"legend-content\" role=\"tooltip\">\n          <div className=\"legend-item\">\n            <div className=\"status-dot\" style={{ backgroundColor: 'green' }} />\n            <span>Complete - All verses recorded</span>\n          </div>\n          <div className=\"legend-item\">\n            <div className=\"status-dot\" style={{ backgroundColor: 'orange' }} />\n            <span>In Progress - Some verses recorded</span>\n          </div>\n          <div className=\"legend-item\">\n            <div className=\"status-dot\" style={{ backgroundColor: 'red' }} />\n            <span>Not Started - No verses recorded</span>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n\n// CSS for responsive design\nconst styles = `\n  .chapter-item {\n    display: flex;\n    flex-direction: column;\n    padding: 12px;\n    border-radius: 8px;\n    margin-bottom: 8px;\n    box-shadow: 0 1px 3px rgba(0,0,0,0.1);\n    transition: all 0.2s ease;\n  }\n  \n  .chapter-item:hover {\n    box-shadow: 0 3px 8px rgba(0,0,0,0.15);\n  }\n  \n  .progress-container {\n    height: 8px;\n    background: #f0f0f0;\n    border-radius: 4px;\n    overflow: hidden;\n    margin-top: 8px;\n    position: relative;\n  }\n  \n  .progress-bar {\n    height: 100%;\n    background: linear-gradient(90deg, #4CAF50, #8BC34A);\n    transition: width 0.3s ease;\n  }\n  \n  @media (max-width: 768px) {\n    .chapter-header {\n      flex-direction: column;\n      align-items: flex-start;\n    }\n    \n    .verse-range {\n      margin-top: 4px;\n    }\n  }\n`;\n```\n\nTesting considerations:\n- Unit tests for status calculation logic\n- Component tests for StatusIndicator and ChapterItem\n- Integration tests for filtering functionality\n- Accessibility tests using axe-core or similar tools\n- Browser compatibility testing across Chrome, Firefox, Safari, and Edge\n\nPerformance optimizations:\n- Virtualized lists for books with many chapters\n- Memoization of filtered chapter lists\n- Debounced search input for real-time filtering\n- Lazy loading of chapter details when expanding books\n</info added on 2025-07-14T13:40:21.490Z>",
          "status": "done",
          "parentTaskId": 8
        },
        {
          "id": 5,
          "title": "Add Action Buttons and Real-time Updates",
          "description": "Implement action buttons for upload and edit functions, and integrate real-time updates using Supabase subscriptions.",
          "dependencies": [
            1,
            3,
            4
          ],
          "details": "1. Add contextual action buttons to book and chapter items:\n   ```jsx\n   function ActionButtons({ itemType, itemId }) {\n     return (\n       <div className=\"action-buttons\">\n         <Button \n           icon=\"upload\" \n           onClick={() => handleUpload(itemType, itemId)}\n           aria-label=\"Upload media\"\n         />\n         <Button \n           icon=\"edit\" \n           onClick={() => handleEdit(itemType, itemId)}\n           aria-label=\"Edit details\"\n         />\n       </div>\n     );\n   }\n   ```\n2. Implement handlers for each action button that open appropriate modals or navigate to edit pages.\n3. Set up Supabase real-time subscriptions to listen for data changes:\n   ```javascript\n   useEffect(() => {\n     const subscription = supabase\n       .from('bible_books')\n       .on('UPDATE', payload => {\n         // Update local state with new data\n         updateBookData(payload.new);\n       })\n       .subscribe();\n       \n     return () => {\n       supabase.removeSubscription(subscription);\n     };\n   }, []);\n   ```\n4. Add visual feedback for real-time updates (e.g., brief highlight of changed items).\n5. Implement optimistic UI updates for better user experience.\n6. Add error handling and retry logic for failed actions.\n7. Testing approach: End-to-end testing with Cypress to verify action button functionality and real-time update behavior.\n\n<info added on 2025-07-14T13:47:11.953Z>\n## Enhanced Implementation Details for Action Buttons and Real-time Updates\n\n### Action Button Implementation Details\n\n```typescript\n// Improved ActionButtons with tooltips and loading states\nfunction ActionButtons({ itemType, itemId, isProcessing = false }) {\n  return (\n    <div className=\"action-buttons\">\n      <Tooltip content=\"Upload media files\">\n        <Button \n          icon=\"upload\" \n          onClick={() => handleUpload(itemType, itemId)}\n          aria-label=\"Upload media\"\n          disabled={isProcessing}\n          className=\"hover:bg-green-100 transition-colors\"\n        />\n      </Tooltip>\n      <Tooltip content=\"Edit details\">\n        <Button \n          icon=\"edit\" \n          onClick={() => handleEdit(itemType, itemId)}\n          aria-label=\"Edit details\"\n          disabled={isProcessing}\n          className=\"hover:bg-blue-100 transition-colors\"\n        />\n      </Tooltip>\n    </div>\n  );\n}\n```\n\n### Optimistic UI Implementation\n\n```typescript\n// Example of optimistic UI update for editing a book title\nfunction handleBookTitleEdit(bookId, newTitle) {\n  // Store original state for rollback\n  const originalBooks = [...books];\n  \n  // Optimistically update UI\n  setBooks(books.map(book => \n    book.id === bookId ? {...book, title: newTitle} : book\n  ));\n  \n  // Perform actual update\n  supabase.from('bible_books')\n    .update({ title: newTitle })\n    .eq('id', bookId)\n    .then(({ error }) => {\n      if (error) {\n        // Rollback on error\n        setBooks(originalBooks);\n        toast.error(\"Failed to update book title\");\n      } else {\n        toast.success(\"Book title updated successfully\");\n      }\n    });\n}\n```\n\n### Enhanced Real-time Subscription Management\n\n```typescript\n// Comprehensive real-time subscription setup with multiple tables\nfunction setupRealTimeSubscriptions(projectId) {\n  const subscriptions = [];\n  \n  // Book changes subscription\n  const bookSubscription = supabase\n    .from(`bible_books:project_id=eq.${projectId}`)\n    .on('*', payload => {\n      handleBookChange(payload);\n    })\n    .subscribe();\n  \n  // Chapter changes subscription\n  const chapterSubscription = supabase\n    .from(`bible_chapters:project_id=eq.${projectId}`)\n    .on('*', payload => {\n      handleChapterChange(payload);\n    })\n    .subscribe();\n  \n  // Media file changes subscription\n  const mediaSubscription = supabase\n    .from(`media_files:project_id=eq.${projectId}`)\n    .on('*', payload => {\n      handleMediaChange(payload);\n    })\n    .subscribe();\n  \n  subscriptions.push(bookSubscription, chapterSubscription, mediaSubscription);\n  \n  return () => {\n    subscriptions.forEach(subscription => {\n      supabase.removeSubscription(subscription);\n    });\n  };\n}\n```\n\n### Visual Feedback for Real-time Updates\n\n```typescript\n// Highlight component for showing recently updated items\nfunction HighlightWrapper({ itemId, updates, children }) {\n  const wasRecentlyUpdated = updates.includes(itemId);\n  const [highlight, setHighlight] = useState(wasRecentlyUpdated);\n  \n  useEffect(() => {\n    if (wasRecentlyUpdated) {\n      setHighlight(true);\n      const timer = setTimeout(() => setHighlight(false), 3000);\n      return () => clearTimeout(timer);\n    }\n  }, [wasRecentlyUpdated, updates]);\n  \n  return (\n    <div className={`transition-all duration-500 ${highlight ? 'bg-yellow-100 shadow-md' : ''}`}>\n      {children}\n    </div>\n  );\n}\n```\n\n### Error Handling and Retry Logic\n\n```typescript\n// Robust error handling with retry logic\nasync function performActionWithRetry(actionFn, maxRetries = 3) {\n  let retries = 0;\n  \n  const execute = async () => {\n    try {\n      return await actionFn();\n    } catch (error) {\n      if (retries < maxRetries) {\n        retries++;\n        const delay = Math.pow(2, retries) * 1000; // Exponential backoff\n        console.warn(`Action failed, retrying in ${delay}ms (${retries}/${maxRetries})`, error);\n        \n        return new Promise(resolve => {\n          setTimeout(() => resolve(execute()), delay);\n        });\n      }\n      \n      throw error; // Max retries exceeded\n    }\n  };\n  \n  return execute();\n}\n\n// Usage example\nfunction handleUpload(itemType, itemId) {\n  setIsUploading(true);\n  \n  performActionWithRetry(() => uploadMedia(itemType, itemId))\n    .then(result => {\n      toast.success(\"Upload successful\");\n    })\n    .catch(error => {\n      toast.error(\"Upload failed after multiple attempts\");\n      console.error(\"Upload error:\", error);\n    })\n    .finally(() => {\n      setIsUploading(false);\n    });\n}\n```\n\n### Testing Approach Details\n\n```typescript\n// Cypress test example for action buttons and real-time updates\ndescribe('Action Buttons and Real-time Updates', () => {\n  beforeEach(() => {\n    cy.login();\n    cy.visit('/dashboard/project/123');\n  });\n  \n  it('should display action buttons on hover', () => {\n    cy.get('.book-item').first().as('firstBook');\n    cy.get('@firstBook').trigger('mouseover');\n    cy.get('@firstBook').find('.action-buttons').should('be.visible');\n    cy.get('@firstBook').find('button[aria-label=\"Upload media\"]').should('be.visible');\n    cy.get('@firstBook').find('button[aria-label=\"Edit details\"]').should('be.visible');\n  });\n  \n  it('should navigate to upload page when upload button is clicked', () => {\n    cy.get('.book-item').first().trigger('mouseover');\n    cy.get('button[aria-label=\"Upload media\"]').first().click();\n    cy.url().should('include', '/upload');\n    cy.url().should('include', 'project=123');\n  });\n  \n  it('should update UI when real-time changes occur', () => {\n    // Simulate a database update via the test backend\n    cy.task('updateDatabase', {\n      table: 'bible_books',\n      id: 1,\n      data: { title: 'Updated Book Title' }\n    });\n    \n    // Check that UI updates without refresh\n    cy.contains('Updated Book Title').should('be.visible');\n    cy.get('.book-item').first().should('have.class', 'bg-yellow-100');\n  });\n});\n```\n</info added on 2025-07-14T13:47:11.953Z>",
          "status": "done",
          "parentTaskId": 8
        }
      ]
    },
    {
      "id": 9,
      "title": "Implement File Upload Interface",
      "description": "Create a drag-and-drop interface for multi-file audio uploads with preview.",
      "status": "done",
      "dependencies": [
        3,
        4,
        6
      ],
      "priority": "high",
      "details": "Successfully implemented a comprehensive drag-and-drop zone supporting multiple audio files with the following features:\n\n- Audio format validation for mp3, m4a, wav, aac, ogg, and webm\n- File size limits (500MB max per file, 50 files max per session)\n- Detailed file preview list with metadata extraction using HTML5 Audio API\n- Individual file removal with confirmation\n- Fallback click-to-browse functionality for browsers without drag-and-drop support\n- Intelligent filename parsing to detect book/chapter information\n- Real-time upload statistics and progress tracking\n- Integrated AudioPlayer component for file preview\n- Comprehensive error handling with detailed messages\n\nImplemented in the AudioUploadPage Component (`src/features/upload/pages/AudioUploadPage.tsx`) with proper routing integration at `/upload` and dashboard navigation.",
      "testStrategy": "Tested drag-and-drop functionality with various file types. Verified rejection of invalid files with appropriate error messages. Confirmed file preview and removal functionality works correctly. Validated metadata extraction accuracy and filename parsing patterns. Tested browser fallback functionality and responsive design across devices. Verified upload progress indicators and statistics dashboard functionality."
    },
    {
      "id": 10,
      "title": "Integrate ffmpeg.wasm for Audio Metadata Extraction",
      "description": "Set up client-side audio processing to extract metadata from audio files.",
      "status": "pending",
      "dependencies": [
        1,
        9
      ],
      "priority": "medium",
      "details": "Install and configure ffmpeg.wasm. Create a service for extracting metadata from audio files. Implement functions to parse ID3 tags. Extract CHAPTER#START/END/NAME/ID format information. Convert timestamps to seconds. Handle errors and fallbacks for files without metadata.",
      "testStrategy": "Test metadata extraction with various audio file formats. Verify timestamp conversion accuracy. Test error handling for files without metadata."
    },
    {
      "id": 11,
      "title": "Implement Filename Parsing Logic",
      "description": "Create robust filename parsing to automatically detect book, chapter, and verse information.",
      "status": "done",
      "dependencies": [
        9
      ],
      "priority": "medium",
      "details": "Implement RegEx patterns for common filename formats: Language_Book_Chapter###_V###_###.mp3, Language_Book_Chapter#.zip, etc. Create a service to extract book, chapter, and verse information from filenames. Handle edge cases and partial matches. Provide fallback UI for manual entry when automatic detection fails.",
      "testStrategy": "Test parsing with various filename formats. Verify that edge cases are handled correctly. Test the fallback manual entry interface."
    },
    {
      "id": 12,
      "title": "Build Upload Review Interface",
      "description": "Create a table view for reviewing detected files before upload.",
      "status": "pending",
      "dependencies": [
        6,
        9,
        10,
        11
      ],
      "priority": "high",
      "details": "Build a table component to display detected files. Show filename, detected book/chapter, verse range, duration, and status. Make book/chapter fields editable with dropdowns. Add validation warnings for missing data. Implement a 'Mark Verses' button for detailed timing. Create a batch upload button with confirmation.",
      "testStrategy": "Test the table view with various file sets. Verify that editable fields work correctly. Test validation warnings for incomplete data. Verify that the 'Mark Verses' button opens the verse marking modal."
    },
    {
      "id": 13,
      "title": "Implement Batch Upload with Progress Tracking",
      "description": "Create a system for uploading multiple files with real-time progress tracking.",
      "status": "pending",
      "dependencies": [
        3,
        4,
        5,
        12
      ],
      "priority": "high",
      "details": "Implement multipart upload for large files. Create a queue system for batch uploads. Add progress tracking per file and overall. Implement error handling and retry logic. Set up database insertion via Supabase. Update UI in real-time during upload. Add cancellation functionality.",
      "testStrategy": "Test uploading multiple files simultaneously. Verify that progress is accurately reported. Test error handling by simulating network failures. Verify that database records are correctly created."
    },
    {
      "id": 14,
      "title": "Create Custom Audio Player Component",
      "description": "Build a custom HTML5 audio player with precise timestamp controls for verse marking.",
      "status": "in-progress",
      "dependencies": [
        6
      ],
      "priority": "medium",
      "details": "Create a custom audio player as a React functional component using HTML5 Audio API with useRef for DOM manipulation. Implement a compound component pattern for modularity with separate sub-components for controls, time display, and progress bar.\n\nCore features:\n- Controls: play/pause, skip ±5s, playback speed (0.5x-4x)\n- Time display: current time, total duration, clickable progress bar for seeking\n- Keyboard shortcuts: spacebar (play/pause), arrow keys (skip), +/- (volume)\n- Playback speed options: 0.5x, 0.75x, 1x, 1.25x, 1.5x, 2x, 3x, 4x\n\nTechnical implementation:\n- Use React hooks (useState, useEffect, useRef, useCallback) for state management\n- Implement event listeners for audio events (timeupdate, ended, loadedmetadata)\n- Add error handling for audio loading and playback issues\n- Ensure proper cleanup of event listeners on unmount\n- Support multiple audio formats with fallback handling\n\nFile structure:\n- Create AudioPlayer component in src/shared/design-system/components/\n- Add AudioPlayer to design system exports\n- Create supporting types and interfaces\n- Add to component demo page for testing\n\nStyle with Tailwind CSS for a consistent look. Make the player responsive for different screen sizes.",
      "testStrategy": "Unit tests for component rendering and state management using Jest and React Testing Library. Integration tests for keyboard shortcuts and controls. Accessibility testing with jest-axe and screen readers. Cross-browser compatibility testing in Chrome, Firefox, and Safari. Responsive design testing on different screen sizes. Verify that all player controls function correctly and timestamp precision for verse marking.",
      "subtasks": [
        {
          "id": "14.1",
          "title": "Set up component structure and file organization",
          "status": "completed",
          "description": "Create the AudioPlayer component in the design system directory with proper file structure and exports."
        },
        {
          "id": "14.2",
          "title": "Implement core audio functionality with React hooks",
          "status": "completed",
          "description": "Set up useRef for audio element and implement basic state management for play/pause, time tracking, and event listeners."
        },
        {
          "id": "14.3",
          "title": "Create sub-components for controls, time display, and progress bar",
          "status": "completed",
          "description": "Build modular sub-components following the compound component pattern for better organization and reusability."
        },
        {
          "id": "14.4",
          "title": "Implement playback speed controls",
          "status": "completed",
          "description": "Add dropdown with multiple playback speed options (0.5x, 0.75x, 1x, 1.25x, 1.5x, 2x, 3x, 4x)."
        },
        {
          "id": "14.5",
          "title": "Add keyboard navigation and shortcuts",
          "status": "completed",
          "description": "Implement keyboard event handlers for spacebar (play/pause), arrow keys (skip), and +/- (volume control)."
        },
        {
          "id": "14.6",
          "title": "Implement accessibility features",
          "status": "completed",
          "description": "Add ARIA labels, ensure keyboard support, and optimize for screen reader compatibility."
        },
        {
          "id": "14.7",
          "title": "Style component with Tailwind CSS",
          "status": "completed",
          "description": "Apply consistent styling using Tailwind CSS and ensure responsive design for different screen sizes."
        },
        {
          "id": "14.8",
          "title": "Write tests for the component",
          "status": "in-progress",
          "description": "Create unit tests for rendering and state management, integration tests for controls and keyboard shortcuts, and accessibility tests using Jest, React Testing Library, and jest-axe."
        },
        {
          "id": "14.9",
          "title": "Add error handling and format support",
          "status": "completed",
          "description": "Implement error handling for audio loading/playback issues and support for multiple audio formats with fallbacks."
        },
        {
          "id": "14.10",
          "title": "Add component to demo page",
          "status": "completed",
          "description": "Integrate the AudioPlayer component into the design system demo page for testing and documentation."
        },
        {
          "id": "14.11",
          "title": "Create Radix UI-based Slider component",
          "status": "completed",
          "description": "Implement a reusable Slider component in src/shared/design-system/components/Slider.tsx with volume and default variants, and add to design system exports."
        },
        {
          "id": "14.12",
          "title": "Implement volume control with mute/unmute functionality",
          "status": "completed",
          "description": "Add volume slider with mute toggle button and keyboard shortcut (M key) for mute/unmute functionality."
        },
        {
          "id": "14.13",
          "title": "Add loading states with spinner indicator",
          "status": "completed",
          "description": "Implement visual feedback during audio loading with spinner indicator to improve user experience."
        },
        {
          "id": "14.14",
          "title": "Add dark mode support",
          "status": "completed",
          "description": "Ensure the AudioPlayer component works properly in dark mode with appropriate styling."
        },
        {
          "id": "14.15",
          "title": "Implement customizable control visibility",
          "status": "completed",
          "description": "Add options to customize visibility for each control group to support different use cases (full-featured, minimal, progress-only)."
        },
        {
          "id": "14.16",
          "title": "Enhance demo page with multiple variants",
          "status": "completed",
          "description": "Update the demo page with multiple AudioPlayer variants, keyboard shortcuts documentation, and event handler examples."
        },
        {
          "id": "14.17",
          "title": "Perform manual testing and cross-browser compatibility",
          "status": "completed",
          "description": "Test all features in different browsers, verify keyboard shortcuts, and ensure accessibility compliance."
        },
        {
          "id": "14.18",
          "title": "Prepare for integration with verse marking functionality",
          "status": "completed",
          "description": "Ensure the AudioPlayer component is ready for integration with verse marking functionality (Task 15)."
        },
        {
          "id": "14.19",
          "title": "Document manual testing results",
          "status": "completed",
          "description": "Document comprehensive testing results including functional testing, browser compatibility, and accessibility testing."
        },
        {
          "id": "14.20",
          "title": "Document integration points for verse marking",
          "status": "completed",
          "description": "Document API interface for verse marking including onTimeUpdate callback, seek functionality, current time access, and event handlers."
        },
        {
          "id": "14.21",
          "title": "Final review before Task 15 integration",
          "status": "pending",
          "description": "Conduct a final code review and ensure all documentation is up-to-date before proceeding with integration with the verse marking modal."
        },
        {
          "id": "14.22",
          "title": "Set up Jest and React Testing Library",
          "status": "pending",
          "description": "Configure Jest and React Testing Library for component testing if not already set up. Add jest-axe for accessibility testing."
        },
        {
          "id": "14.23",
          "title": "Create test files for AudioPlayer and Slider components",
          "status": "pending",
          "description": "Create comprehensive test files covering rendering, state management, user interactions, and accessibility."
        },
        {
          "id": "14.24",
          "title": "Verify timestamp precision for verse marking",
          "status": "pending",
          "description": "Test and ensure audio seeking accuracy and timestamp precision for fine-grained control needed for verse boundary marking."
        }
      ]
    },
    {
      "id": 15,
      "title": "Implement Verse Marking Modal",
      "description": "Create a modal interface for marking verse timestamps in audio files.",
      "status": "pending",
      "dependencies": [
        6,
        14
      ],
      "priority": "high",
      "details": "Build a modal component for verse marking. Integrate the custom audio player. Create a chronologically ordered verse list with editable start times. Implement auto-reordering when times are edited. Add delete functionality for verse markers. Implement a 'Mark Verse' button that adds a verse at the current timestamp. Add validation against chapter.total_verses.",
      "testStrategy": "Test adding, editing, and deleting verse markers. Verify that auto-reordering works correctly. Test validation against chapter verse counts. Ensure the modal is accessible."
    },
    {
      "id": 16,
      "title": "Develop Timeline Editor for Verse Segments",
      "description": "Create a visual timeline representation of verse segments within the audio file.",
      "status": "pending",
      "dependencies": [
        14,
        15
      ],
      "priority": "medium",
      "details": "Build a visual timeline component showing the audio waveform (if possible) or time segments. Display verse markers on the timeline. Allow clicking on the timeline to navigate to that position. Implement dragging verse markers to adjust timestamps. Ensure the timeline is synchronized with the audio player. Add visual indicators for verse coverage and gaps.",
      "testStrategy": "Test timeline navigation by clicking. Verify that verse markers are correctly positioned. Test dragging markers to adjust timestamps. Ensure the timeline stays synchronized with the audio player."
    },
    {
      "id": 17,
      "title": "Implement Text Version Management",
      "description": "Create interfaces for managing multiple text versions per project.",
      "status": "pending",
      "dependencies": [
        3,
        4,
        5,
        6,
        8
      ],
      "priority": "medium",
      "details": "Build a text version management interface. Create forms for adding new text versions with name and Bible version selection. Implement listing, editing, and deleting text versions. Add version comparison functionality. Create a default version selector. Integrate with the project dashboard.",
      "testStrategy": "Test adding, editing, and deleting text versions. Verify that the default version selector works correctly. Test integration with the project dashboard."
    },
    {
      "id": 18,
      "title": "Implement CSV Text Upload",
      "description": "Create a system for bulk verse text upload via CSV files.",
      "status": "pending",
      "dependencies": [
        5,
        6,
        17
      ],
      "priority": "medium",
      "details": "Build a CSV upload component. Implement CSV parsing with validation. Create a preview table showing parsed data. Add highlighting for unrecognized verses. Display statistics: total rows, valid verses, errors. Add edit functionality for corrections. Implement final validation and database insertion logic.",
      "testStrategy": "Test CSV upload with various file formats. Verify that parsing errors are correctly identified. Test the preview and editing functionality. Verify that data is correctly saved to the database."
    },
    {
      "id": 19,
      "title": "Implement Verse Text-Audio Linking",
      "description": "Create functionality to automatically associate verse texts with audio timings.",
      "status": "pending",
      "dependencies": [
        15,
        16,
        18
      ],
      "priority": "medium",
      "details": "Implement logic to link verse texts with audio verse markers. Create a UI for reviewing and adjusting these associations. Add validation to ensure all verses have text. Implement batch association for efficiency. Update database relationships in media_files_verses.verse_text_id.",
      "testStrategy": "Test automatic association with various scenarios. Verify that manual adjustments work correctly. Test validation for complete coverage. Verify that database relationships are correctly updated."
    },
    {
      "id": 20,
      "title": "Create Supabase Edge Functions for API Endpoints",
      "description": "Implement serverless functions for complex operations like file upload and metadata extraction.",
      "status": "pending",
      "dependencies": [
        5,
        13
      ],
      "priority": "high",
      "details": "Create Supabase Edge Functions for: upload_audio, create_project, extract_metadata, bulk_text_upload. Implement proper error handling and validation. Set up authentication and authorization checks. Add logging for debugging. Create TypeScript interfaces for request/response types.",
      "testStrategy": "Test each function with various input scenarios. Verify error handling for invalid inputs. Test authentication and authorization rules. Verify that functions perform their intended operations correctly."
    },
    {
      "id": 21,
      "title": "Implement Real-time Updates with Supabase Subscriptions",
      "description": "Set up real-time data synchronization for collaborative features.",
      "status": "pending",
      "dependencies": [
        4,
        5,
        8
      ],
      "priority": "medium",
      "details": "Configure Supabase real-time subscriptions for relevant tables. Create custom hooks for subscription management. Implement UI updates based on subscription events. Handle subscription errors and reconnection. Optimize performance by limiting subscription scope.",
      "testStrategy": "Test real-time updates by modifying data from another client. Verify that UI updates correctly in response to subscription events. Test error handling and reconnection logic."
    },
    {
      "id": 22,
      "title": "Implement Caching and Performance Optimizations",
      "description": "Optimize application performance with caching strategies and lazy loading.",
      "status": "pending",
      "dependencies": [
        4,
        8,
        13
      ],
      "priority": "low",
      "details": "Implement aggressive caching for language/region hierarchies. Add pagination for large datasets. Optimize component rendering with React.memo and useMemo. Implement code splitting for large components. Add lazy loading for images and non-critical resources. Set up performance monitoring.",
      "testStrategy": "Measure and compare load times before and after optimizations. Test pagination with large datasets. Verify that caching works correctly. Use React DevTools to identify and fix performance bottlenecks."
    },
    {
      "id": 23,
      "title": "Implement Error Handling and Validation",
      "description": "Create comprehensive error handling and validation throughout the application.",
      "status": "pending",
      "dependencies": [
        2,
        3,
        4,
        13
      ],
      "priority": "medium",
      "details": "Implement form validation using a library like Zod or Yup. Create error boundary components for React errors. Add global error handling for API requests. Implement user-friendly error messages and recovery options. Add validation for all user inputs. Create a toast notification system for errors and success messages.",
      "testStrategy": "Test form validation with valid and invalid inputs. Verify that API errors are properly handled and displayed. Test error boundaries by intentionally causing errors. Ensure that error messages are user-friendly and actionable."
    },
    {
      "id": 24,
      "title": "Implement Responsive Design and Accessibility",
      "description": "Ensure the application is responsive and meets WCAG 2.1 AA compliance.",
      "status": "pending",
      "dependencies": [
        6,
        8,
        9,
        12,
        15
      ],
      "priority": "medium",
      "details": "Implement responsive layouts using Tailwind CSS breakpoints. Add keyboard navigation for all interactive elements. Ensure proper contrast ratios for text. Add ARIA attributes for screen readers. Implement focus management for modals and dialogs. Test and fix tab order for logical navigation. Add skip links for keyboard users.",
      "testStrategy": "Test on various screen sizes and devices. Use accessibility tools like axe or Lighthouse to identify issues. Test with keyboard-only navigation. Verify that screen readers can properly interpret the application."
    },
    {
      "id": 25,
      "title": "Configure Deployment to Vercel",
      "description": "Set up continuous deployment to Vercel with environment configuration.",
      "status": "pending",
      "dependencies": [
        1,
        2,
        3,
        4,
        5,
        20
      ],
      "priority": "low",
      "details": "Create Vercel project and link to repository. Configure environment variables for different environments (development, staging, production). Set up build and deployment scripts. Configure custom domain if needed. Implement preview deployments for pull requests. Add monitoring and error tracking.",
      "testStrategy": "Verify that the application builds and deploys successfully. Test environment-specific configuration. Verify that preview deployments work for pull requests. Test the application in the production environment."
    }
  ],
  "metadata": {
    "projectName": "Audio Upload Website",
    "totalTasks": 25,
    "sourceFile": "PRD.txt",
    "generatedAt": "2023-11-15"
  }
}